\section{Espacios topológicos en Lean}

Explicar algunos ejemplos de definiciones y demostraciones, no a modo de explicación completa de los prerrequisitos de topología sino para tener un primer acercamiento sencillo a la topología en Lean.

Nota: toda esta sección se basa en el Willard en principio (para la teoría).

\subsection{Espacios topológicos}

\begin{definition}[\textbf{Espacio topológico}]\label{def:espacio-topologico}
    Sea $X$ un conjunto y $\mathcal{T}$ una colección de subconjuntos de $X$ de forma que
    \begin{enumerate}
      \item Los conjuntos $\emptyset$ y $X$ pertenecen a $\mathcal{T}$.
      \item Cualquier intersección finita de elementos de $\mathcal{T}$ pertenece a $\mathcal{T}$.
      \item Cualquier unión arbitraria de elementos de $\mathcal{T}$ pertenece a $\mathcal{T}$.
    \end{enumerate}
    Entonces diremos que $\mathcal{T}$ es una \textnormal{topología} sobre $X$, que $(X, \mathcal{T})$ es un \textnormal{espacio topológico} y que los elementos de $\mathcal{T}$ son \textnormal{abiertos} en este espacio.
\end{definition}

En Lean, esta definición se escribe como una estructura que consta de cuatro elementos:

\begin{lstlisting}
  class TopologicalSpace (X : Type u) where
    IsOpen : Set X → Prop
    isOpen_univ : IsOpen Set.univ
    isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)
    isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)
\end{lstlisting}

El primer elemento, \code{IsOpen}, es una función que lleva cada conjunto de $X$ en una proposición, es decir, es una descripción de los elementos de $\mathcal{T}$ como el conjunto \code{\{U $\in$ Set (X) | IsOpen U\}}. Los otros tres elementos son demostraciones de las propiedades de la definición.

Veamos algunos ejemplos y sus demostraciones en Lean.

\begin{example}
    Sea $X$ un conjunto cualquiera. Consideremos la colección $\mathcal{T}$ de todos los subconjuntos de $\mathcal{T}$. Entonces $\mathcal{T}$ es una topología sobre $X$, a la que llamamos \textnormal{topología discreta}.
\end{example}

\begin{proof}
  Podemos describir $\mathcal T$ como \code{\{U $\in$ Set (X) | True\}}, porque \code{IsOpen} es cierto para cualquier $U$.

  \begin{lstlisting}
  def DiscreteTopo (X : Type) : TopologicalSpace X where
    IsOpen (_ : Set X) := true \end{lstlisting}
  
  Ahora, demostrar el resto de propiedades es sencillo:

  \begin{minipage}[t]{0.58\textwidth}
\begin{lstlisting}[language=lean]
    isOpen_univ := by
  ~
\end{lstlisting}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.40\textwidth}
\begin{lstlisting}[language=infoview]
  ⊢ (fun x ↦ true = true) Set.univ
\end{lstlisting}
\end{minipage}

Aplicar la función \code{fun x $\mapsto$ true} a cualquier conjunto retorna siempre \code{true}, por tanto basta con usar \bluecode{trivial}.

\begin{lstlisting}
  def DiscreteTopo (X : Type) : TopologicalSpace X where
    IsOpen (_ : Set X) := true
    isOpen_univ := by
      trivial
    isOpen_inter := by
      intros
      trivial
    isOpen_sUnion := by
      intros
      trivial
\end{lstlisting}

\end{proof}


\begin{example}
    Sea $X$ un conjunto cualquiera. Consideremos la colección $\mathcal{T}=\{\emptyset, X\}$. Entonces $\mathcal{T}$ es una topología sobre $X$, a la que llamamos \textnormal{topología trivial}.
\end{example}

\begin{proof}
  Podemos describir $\mathcal{T}$ como \code{\{U $\in$ Set (X) | U = X $\lor$ U = $\emptyset$\}}.

  \begin{lstlisting}
  def TrivialTopology (X : Type) : TopologicalSpace X where
    IsOpen (s : Set X) := s = Set.univ ∨ s = ∅ \end{lstlisting}

  La primera condición se cumple trivialmente: queremos ver $X = X \lor X = \emptyset$.

  \begin{lstlisting}
    isOpen_univ := by
      left
      rfl\end{lstlisting}

  Consideremos ahora dos abiertos (\bluecode{intro}). Diferenciamos en casos:

  \begin{lstlisting}
    isOpen_inter := by
      intro s t hs ht
      cases' hs with hs_univ hs_empty
      cases' ht with ht_univ ht_empty \end{lstlisting}

  Si ambos son $X$, la intersección será $X$ y por tanto abierta. Si uno de los dos es vacío, entonces la intersección es vacía, también abierta.

  \begin{lstlisting}
      · left -- s, t = Set.univ, s ∩ t = Set.univ ?
        rw [hs_univ, ht_univ]
        simp
      · right -- t = ∅, s ∩ t = ∅ ?
        rw [ht_empty]
        simp
      · right -- s = ∅, s ∩ t = ∅ ?
        rw [hs_empty]
        simp \end{lstlisting}

  Consideremos finalmente una colección arbitraria $S$ de abiertos. Para ver si la unión es abierta, consideramos dos casos distintos: o bien $X$ está en $S$, en cuyo caso la unión en $X$, o bien no lo está, en cuyo caso todos los conjuntos son vacíos y la unión también lo es.

  \begin{lstlisting}
    isOpen_sUnion := by
      intro S hS
      cases' Classical.em (Set.univ ∈ S) with h1 h2

      · left -- h1 : Set.univ ∈ S, ⋃₀S = Set.univ ?
        ext s
        constructor
        · intro hs -- hs : s ∈ S, s ∈ Set.univ ?
          trivial
        · intro hs -- hs : s ∈ Set.univ, s ∈ S ?
          use Set.univ -- utiliza h1 implicitamente

      · right -- h2 : Set.univ ∉ S, ⋃₀S = ∅ ?
        simp -- ∀ s ∈ S, s = ∅ ?
        intro s hs
        specialize hS s hs -- aplicar definicion de abierto
        cases' hS with hS hS -- dividir en casos
        · by_contra -- si s = Set.univ, contradiccion
          rw [hS] at hs 
          exact h2 hs -- porque s ∈ S, pero Set.univ ∉ S
        · exact hS -- si s = ∅ \end{lstlisting}
\end{proof}


\begin{example}

  Consideremos la recta real y consideremos la definición usual de conjunto abierto en $\mathbb{R}$, es decir, $A \subseteq \mathbb{R}$ es abierto si y solo si para cada punto $x \in A$ existe una bola abierta centrada en $x$ enteramente contenida en $A$. Sea $\mathcal{T}$ la colección de estos abiertos. Entonces $\mathcal{T}$ es una topología sobre $\mathbb{R}^2$, a la que llamamos \textnormal{topología usual}.
\end{example}

\begin{proof}
  En Lean, podemos describir este espacio topológico dando sus elementos de la siguiente forma, donde cada objeto esta definido anteriormente.

  
  \begin{lstlisting}
  def UsualTopology : TopologicalSpace ℝ where
    IsOpen := Real.IsOpen
    isOpen_univ := Real.isOpen_univ
    isOpen_inter := Real.isOpen_inter
    isOpen_sUnion := Real.isOpen_sUnion \end{lstlisting}
  
  La definición de abierto se puede escribir así:

  \begin{lstlisting}
  def Real.IsOpen (s : Set ℝ) : Prop :=
    ∀ x ∈ s, ∃ δ > 0, ∀ y : ℝ, x - δ < y ∧ y < x + δ → y ∈ s \end{lstlisting}

  Damos la demostración para la intersección finita. El resto utilizan mecanismos parecidos.

  Sean por tanto dos subconjuntos $s$ y $t$ de $\mathcal{T}$. Sea $x \in t \cap s$ y queremos ver que existe una bola abierta centrada en $x$ y contenida en $t \cap s$.

  \begin{lstlisting}
  lemma Real.isOpen_inter (s t : Set ℝ)
      (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s ∩ t) := by
    intro x hx -- x ∈ s ∩ t, ∃ δ > 0, ∀ (y : ℝ), ... → y ∈ s ∩ t ? \end{lstlisting}

  Puesto que $x \in s$, existe un $\delta_1>0$ (\code{h$\delta$1}) de forma que $B_{\delta_1}(x) \subseteq s$ (\code{hs}). Análogamente, existe un $\delta_2>0$ (\code{h$\delta$2}) de forma que $B_{\delta_2}(x) \subseteq t$ (\code{ht}). Basta con tomar $\delta = \min \{\delta_1, \delta_2\}$.

  \begin{lstlisting}
    obtain ⟨δ1, hδ1, hs⟩ := hs x hx.left
    obtain ⟨δ2, hδ2, ht⟩ := ht x hx.right
    use min δ1 δ2 \end{lstlisting}

  Trivialmente $\delta > 0$.
  
  \begin{lstlisting}
    constructor
    · exact lt_min hδ1 hδ2 \end{lstlisting}

  Para ver que $B_\delta (x) \subseteq s \cap t$, consideramos $y \in B_\delta(x)$ y queremos ver que $y \in s$ y que $y \in t$. Para ver $y \in s$, como $B_{\delta_1}(x) \subseteq s$ (\code{hs}), basta ver $y \in B_{\delta_1}(x)$.

  \begin{lstlisting}
    · intro y hy
      constructor
      · apply hs -- x - δ1 < y ∧ y < x + δ1 ? \end{lstlisting}

  En realidad, esta condición se reduce a dos inecuaciones, que son fáciles de probar contando con que $\delta \leq \delta_1$ (\code{h$\delta$}).

  \begin{lstlisting}
      have hδ := min_le_left δ1 δ2
      constructor
      all_goals linarith \end{lstlisting}

  Probar que $y \in t$ es análogo.
  
\end{proof}


\subsubsection{Entornos abiertos}

Como hemos dicho, los conjuntos abiertos en un espacio topológico son los elementos de la topología. En Lean, es una función \code{TopologicalSpace.IsOpen} de tipo \code{Set X $\to$ \blue{Prop}}. Podemos utilizar esta definición directamente para demostrar que un abierto lo es.

\begin{example} 
    Por ejemplo, por definición, el universo, $X$, siempre es abierto. En efecto:
\end{example}

\begin{lstlisting}
  example (X : Type) [T : TopologicalSpace X] : T.IsOpen Set.univ := by
    exact TopologicalSpace.isOpen_univ \end{lstlisting}

\begin{definition}[\textbf{Entorno abierto}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $x \in X$. Un \textnormal{entorno abierto} de $x$ en $X$ es un conjunto abierto $U \in \mathcal{T}$ de forma que $x \in U$.
\end{definition}

\begin{lstlisting}
  def OpenNeighbourhood {X : Type} [TopologicalSpace X]
    (U : Set X) (x : X) : Prop :=
    x ∈ U ∧ IsOpen U
\end{lstlisting}

\begin{example}
  El universo es entorno abierto de cualquier punto $x \in X$. En efecto:
\end{example}

\begin{lstlisting}
  example {X : Type} [TopologicalSpace X] (x : X) :
      OpenNeighbourhood Set.univ x := by
    constructor
    · trivial -- x ∈ Set.univ ?
    · exact isOpen_univ -- IsOpen Set.univ ? \end{lstlisting}

\begin{definition}[\textbf{Entorno}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $x \in X$. Un \textnormal{entorno} de $x$ en $X$ es un conjunto $V \subseteq X$ de forma que existe un entorno abierto de $x$, $U \in \mathcal{T}$, con $U \subseteq V$.
\end{definition}

\begin{lstlisting}
  def Neighbourhood {X : Type} [TopologicalSpace X]
    (V : Set X) (x : X) : Prop :=
    ∃ U : Set X, U ⊆ V ∧ OpenNeighbourhood U x
\end{lstlisting}

\begin{example}
  Un entorno abierto es también un entorno. En efecto:
\end{example}

\begin{lstlisting}
  example {X : Type} [TopologicalSpace X] (U : Set X) (x : X) :
      OpenNeighbourhood U x → Neighbourhood U x := by
    intro hU
    use U -- usamos el propio U como abierto
\end{lstlisting}

\begin{lstlisting}
  Nota: deberia marcar de alguna forma cuando una demostracion esta terminada en Lean??? porque aqui parece que no pero realmente esta terminada
\end{lstlisting}

\begin{proposition}[\textbf{Caracterización de conjuntos abiertos}]\label{caracterizacion-abierto}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq U$ un conjunto cualquiera. $A$ es abierto si y solo si es entorno de todos sus puntos.
\end{proposition}

\begin{lstlisting}
  lemma A_open_iff_neighbourhood_of_all {X : Type}
      [T : TopologicalSpace X] {A : Set X} :
      IsOpen A ↔ ∀ x ∈ A, Neighbourhood A x
\end{lstlisting}

\begin{proof}
  Demostramos cada implicación separadamente.

  \begin{lstlisting}
      := by
    constructor; all_goals intro h \end{lstlisting}

  $(\implies)$ La primera implicación es sencilla: si $A$ es abierto, para cada $x \in A$ basta tomar $A$ como entorno de $x$.

  \begin{lstlisting}
    · intro x hx -- hx : x ∈ A
      use A
      constructor
      · trivial -- A ⊆ A ?
      · constructor
        · exact hx -- x ∈ A ?
        · exact h -- IsOpen A ? \end{lstlisting}

  $(\impliedby)$ El recíproco es más complicado. Sabemos que para cada $a \in A$ existe $U_a$ entorno de $a$. Primero probaremos que
  $$
  A = \bigcup_{a \in A} U_a
  $$
  \begin{lstlisting}
    · have hUnion : A = ⋃ x : A, Classical.choose (h x x.property) \end{lstlisting}
  Para ello, probamos ambas inclusiones. Si $x \in A$, entonces por nuestra hipótesis existe un entorno de $x$, $U_x$. Y por la definición de entorno, eso quiere decir que $x \in U_x$. Luego $x \in \bigcup_{a}U_a$.

  \begin{lstlisting}
      · ext x; constructor; all_goals intro hx
        · have ⟨_, hUx⟩  := Classical.choose_spec (h x hx)
           -- hUx : OpenNeigh. Ux x
          simp -- ∃ a ∈ A, x ∈ Ua ?
          use x, hx
          exact hUx.left \end{lstlisting}

  Ahora, si $x \in \bigcup_{a}U_a$, entonces existe un $a \in A$ con $x \in U_a$ y $U_a$ entorno abierto de $a$ con $U_a \subseteq A$. Luego $x \in U_a \subseteq A$.

  \begin{lstlisting}
        · simp at hx
          obtain ⟨a, ha, hx⟩ := hx -- hx : x ∈ Ua
          have ⟨ha', _⟩ := Classical.choose_spec (h a ha)
          apply ha'
          exact hx \end{lstlisting}
  
  Entonces hemos probado que $A$ se expresa como una unión de conjuntos $U_a$. Pero sabemos que todos estos conjuntos son entornos abiertos, luego son abiertos. Basta aplicar que la unión de abiertos es abierta.

  \begin{lstlisting}
      rw [hUnion]
      apply isOpen_iUnion
      intro a
      exact (Classical.choose_spec (h a a.property)).right.right \end{lstlisting}
\end{proof}


\paragraph{Interior}

\begin{definition}
    Sea $(X, \mathcal{T})$ un espacio topológico, $A \subseteq X$ y $x \in X$. Decimos que $x$ es un punto \textnormal{interior} de $A$ si $A$ es entorno de $x$.

    El \textnormal{interior} de $A$ es el conjunto de los puntos interiores de $A$, y se denota por $\overset{\circ}{A}$.
\end{definition}

Podemos describir el anterior conjunto como
$$
\overset{\circ}{A} = \bigcup \left\{ U \subseteq X | U \text{ es abierto y } U \subseteq A \right\}
$$
En Mathlib, el interior de un conjunto está definido de la misma forma.

\begin{lstlisting}
  def interior (s : Set X) : Set X :=
    ⋃₀ { t | IsOpen t ∧ t ⊆ s }
\end{lstlisting}

Veamos varias propiedades del interior de un conjunto.

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces
  $$
  \overset{\circ}{A} \subseteq A
  $$
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{interior\_subset}.

\begin{proof}
  Sea $a \in \overset{\circ}{A}$. Entonces $A$ es entorno de $a$ y existe un abierto con $a \in U \subseteq A$. Luego $a \in A$.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      interior A ⊆ A := by
    intro a ha
    obtain ⟨U, hU, ha⟩ := ha -- hU : IsOpen U ∧ U ⊆ A, ha : a ∈ U
    apply hU.right
    exact ha \end{lstlisting}
\end{proof}

\begin{proposition}
    Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $\overset{\circ}{A}$ es un conjunto abierto.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{isOpen\_interior}

\begin{proof}
  Por la caracterización de conjuntos abiertos \pref{caracterizacion-abierto}, basta ver que dado un $a \in \overset{\circ}{A}$, $\overset{\circ}{A}$ es entorno de $a$.
  
  Si $a \in \overset{\circ}{A}$, entonces existe abierto $U$ con $a \in U \subseteq A$. Usamos este $U$ para demostrar que $\overset{\circ}{A}$ es entorno de $a$.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsOpen (interior A) := by
    apply A_open_iff_neighbourhood_of_all.mpr
    intro a ha
    obtain ⟨U, hU, ha⟩ := ha -- hU : IsOpen U ∧ U ⊆ A, ha : a ∈ U
    use U
    constructor
    · intro x hx -- U ⊆ interior A ?
      use U
    · constructor
      · exact ha -- a ∈ U ?
      · exact hU.left -- IsOpen U ?\end{lstlisting}
\end{proof}


\begin{proposition}
    Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $A$ es abierto si y solo si $A$ es igual a su interior.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{interior\_eq\_iff\_isOpen}

\begin{proof}
  El recíproco es trivial, pues ya hemos visto que el interior de un conjunto es abierto.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsOpen A ↔ interior A = A:= by
    constructor; swap; all_goals intro h
    · rw [← h]
      exact isOpen_interior \end{lstlisting}

  Ahora, supongamos que $A$ es abierto. Ya hemos visto que $\overset{\circ}{A} \subseteq A$, luego basta ver el otro contenido. Sea $a \in A$. Como $A$ es abierto, es un entorno abierto de $a$ con $A \subseteq A$. Luego $a \in \overset{\circ}{A}$.
  
  \begin{lstlisting}
    · apply Set.Subset.antisymm
      · exact interior_subset
      · intro a ha
        use A
        constructor
        · simp
          exact h
        · exact ha \end{lstlisting}
\end{proof}


\subsubsection{Conjuntos cerrados}

\begin{definition}[\textbf{Conjunto cerrado}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Decimos que
\end{definition}

\begin{example}
    El universo es cerrado
\end{example}

\begin{example}
    La intersección arbitraria de cerrados es cerrada
\end{example}

\paragraph{Clausura}

\begin{definition}
    Clausura
\end{definition}

\begin{proposition}
    El conjunto está en la clausura
\end{proposition}

\begin{proposition}
    La clausura es cerrada
\end{proposition}

\begin{proposition}
    El complementario de la clausura es el interior del complementario
\end{proposition}

\begin{proposition}
    A es cerrado si y solo si es igual a su clausura
\end{proposition}



\subsection{Bases}

\begin{definition}
  Base de una topología: isTopoBase
\end{definition}

\begin{example}
  BaseOfRealTopo
\end{example}

\subsection{Topología relativa}

\begin{definition}
  Topología del subespacio (TopoSubspace)
\end{definition}

\begin{example}
  La topología del subespacio [0, 1]; [0, b) es abierto en [0, 1] con la topología usual
\end{example}


\subsection{Continuidad}





\subsection{Separación}



\subsubsection{Espacios de Hausdorff}

\newpage
\subsubsection{Espacios normales}

Introducción : ¿por qué son interesantes?

\begin{definition}
  Sea $X$ un espacio topológico. $X$ es \emph{normal} si para cada par de cerrados disjuntos $C, D \subseteq X$ existen abiertos disjuntos $U$ y $V$ en $X$ tales  que separan $C$ y $D$, es decir, $C \subseteq U$ y $D \subseteq V$ \textnormal{(véase \cite[p. 99]{willard2012general})}.
\end{definition}

En Lean, escribimos esta definición de la siguiente forma.

\begin{lstlisting}
  def NormalTopoSpace {X : Type} (T : TopologicalSpace X) : Prop :=
    ∀ C : Set X, ∀ D : Set X,
    IsClosed C → IsClosed D → C ∩ D = ∅ →
    ∃ U : Set X, ∃ V : Set X,
      IsOpen U ∧
      IsOpen V ∧
      C ⊆ U ∧
      D ⊆ V ∧
      U ∩ V = ∅
\end{lstlisting}

Ahora queremos dar una caracterización para este tipo de espacios, que nos facilitará el trabajo más adelante.

\begin{proposition}[\textbf{Caracterización de la normalidad}]
  Sea $X$ un espacio topológico. $X$ es normal si y sólo si para cada abierto $U$ y cada cerrado $C$ de $X$ tales que $C \subseteq U$, existe un abierto $V \subset X$ de forma que $C \subseteq V \subseteq \overline{V} \subseteq U$.
\end{proposition}

En Lean, escribimos:

\begin{lstlisting}
  lemma characterization_of_normal {X : Type}
    (T : TopologicalSpace X) :
    NormalTopoSpace T ↔
      ∀ U : Set X, ∀ C : Set X, IsOpen U → IsClosed C → C ⊆ U →
      ∃ V : Set X, IsOpen V ∧ C ⊆ V ∧ (Closure V) ⊆ U := by sorry
\end{lstlisting}

\begin{proof}
  Veamos primero una implicación, y luego la otra (utilizamos \bluecode{constructor}).

  ($\implies$) Supongamos que $X$ es un espacio normal (\code{hT}) y sean $U$ un abierto (\code{hU}) y $C$ un cerrado (\code{hC}) tales que $C \subseteq U$ (\code{hCU}).

\begin{lstlisting}
    intro hT U C hU hC hCU
\end{lstlisting}
  
  Puesto que $X$ es normal, por la definición, para $C$ y $U^c$ cerrados en $X$ obtenemos $V_1$ y $V_2$ abiertos (\code{V1\_open}, \code{V2\_open}) disjuntos (\code{hV}) tales que $C \subseteq V_1$ (\code{hCV}) y $U^c \subseteq V_2$ (\code{hUV}).

\begin{lstlisting}
  obtain ⟨V1, V2, V1_open, V2_open, hCV, hUV, hV⟩ :=
    hT C Uᶜ
    hC
    (by exact isClosed_compl_iff.mpr hU)
    (by rw [ABdisjoint_iff_AsubsBc, compl_compl]; exact hCU)
\end{lstlisting}

  Por supuesto, en Lean tenemos que especificar por qué $U^c$ es cerrado y por qué $U^c \subseteq V_2$. Ahora tenemos una hipótesis de la forma

\begin{lstlisting}
  h : IsOpen V1 ∧ IsOpen V2 ∧ C ⊆ V1 ∧ Uᶜ ⊆ V2 ∧ V1 ∩ V2 = ∅
\end{lstlisting}
  
  Tomamos como $V$ el $V_1$ obtenido de esta forma,

\begin{lstlisting}
    use V1
\end{lstlisting}

  Queremos ver que satisface las condiciones que le pedimos:

\begin{lstlisting}
  ⊢ IsOpen V1 ∧ C ⊆ V1 ∧ Closure V1 ⊆ U
\end{lstlisting}
  
  Cómo tiene que cumplir tres condiciones, tendremos que utilizar \bluecode{constructor} varias veces. En primer lugar, $V_1$ es abierto por construcción. Además, $C \subseteq V_1$ también por construcción.

\begin{lstlisting}
    constructor
    · exact V1_open
    constructor
    · exact hCV
\end{lstlisting}

  Ahora queda demostrar que $\overline{V_1} \subseteq U$. Por un lado, tenemos que $V_1$ y $V_2$ son disjuntos, luego, en particular, como $V_2$ es abierto, se tiene que $\overline{V_1}$ y $V_2$ son disjuntos.

\begin{lstlisting}
    · apply disjointU_V_then_disjointClosureU_V V2_open at hV
      apply Set.disjoint_iff_inter_eq_empty.mpr at hV -- usamos la propiedad Disjoint de Lean
\end{lstlisting}

  Por otro lado, tenemos que $\overline{V_1} \subseteq U$ $\iff$ $V_1$ y $U^c$ son disjuntos. Basta ver que lo son utilizando lo anterior, sabiendo que $U^c \subseteq V_2$.

\begin{lstlisting}
      apply Set.disjoint_compl_right_iff_subset.mp
      exact Set.disjoint_of_subset_right hUV hV
\end{lstlisting}

  ($\Longleftarrow$) Procedemos de manera similar. Sean $C_1$, $C_2$ cerrados (\code{C1\_closed}, \code{C2\_closed}) disjuntos (\code{hC}). Podemos aplicar la hipótesis (\code{h}) al abierto $C_1^c$ y al cerrado $C_2$ para obtener obtener un abierto $V$ (\code{V\_open}) de manera que $C_2 \subseteq V \subseteq \overline{V} \subseteq C_1^c$ (\code{hV}).

\begin{lstlisting}
    intro h C1 C2 C1_closed C2_closed hC
    obtain ⟨V, V_open, hV⟩ :=
      h C1ᶜ C2
      (by exact IsClosed.isOpen_compl)
      C2_closed
      (by rw [← ABdisjoint_iff_AsubsBc, Set.inter_comm C2 C1]; exact hC)
\end{lstlisting}

  Ahora tomamos los abiertos $U_1 = \overline{V}^c$ y $U_2 = V$. Queremos ver que cumplen la condición de normalidad para $C_1$ y $C_2$.
  
\begin{lstlisting}
  IsOpen (Closure V)ᶜ ∧ IsOpen V ∧ C1 ⊆ (Closure V)ᶜ ∧ C2 ⊆ V ∧ (Closure V)ᶜ ∩ V = ∅
\end{lstlisting}
  
  En efecto, ambos son abiertos ($\overline{V}^c$ por ser el complementario de una clausura y $V$ por construcción).

\begin{lstlisting}
    constructor
    · simp
      exact closure_is_closed V
    constructor
    · exact V_open
\end{lstlisting}

  Además, $C_1 \subseteq \overline{V}^c$ es equivalente a $\overline{V} \subseteq C_1^c$, que es cierto por construcción de $V$, igual que $C_2 \subseteq V$.
  
\begin{lstlisting}
    constructor
    · apply Set.subset_compl_comm.mp
      exact hV.right
    constructor
    · exact hV.left
\end{lstlisting}

  Por último, se tiene

  $$
  \overline{V}^c \cap V = \emptyset \iff V \cap \overline{V}^c = \emptyset \iff
  V \subseteq \overline{V}^{cc} \iff V \subseteq \overline{V},
  $$

  que es cierto por las propiedades de la adherencia.

\begin{lstlisting}
    · rw [Set.inter_comm]
      rw [ABdisjoint_iff_AsubsBc]
      simp
      exact set_inside_closure V
\end{lstlisting}


\end{proof}