\section{Espacios topológicos en Lean}

En esta sección veremos cómo se representan en Lean algunos conceptos básicos de topología general. El objetivo no es desarrollar la teoría completa, sino mostrar ejemplos concretos de definiciones y demostraciones formales, que sirvan como primer contacto con el trabajo en Lean sobre espacios topológicos.

Las definiciones y resultados matemáticos utilizados son los habituales en topología general. Aunque inicialmente me basé en los apuntes que tomé en la asignatura Topología Elemental, posteriormente los he contrastado con \cite{willard2012general} como referencia estándar.

\subsection{Espacios topológicos}

\begin{definition}[\textbf{Espacio topológico}]\label{def:espacio-topologico}
    Sea $X$ un conjunto y $\mathcal{T}$ una colección de subconjuntos de $X$ de forma que
    \begin{enumerate}
      \item Los conjuntos $\emptyset$ y $X$ pertenecen a $\mathcal{T}$.
      \item Cualquier intersección finita de elementos de $\mathcal{T}$ pertenece a $\mathcal{T}$.
      \item Cualquier unión arbitraria de elementos de $\mathcal{T}$ pertenece a $\mathcal{T}$.
    \end{enumerate}
    Entonces diremos que $\mathcal{T}$ es una \textnormal{topología} sobre $X$, que $(X, \mathcal{T})$ es un \textnormal{espacio topológico} y que los elementos de $\mathcal{T}$ son \textnormal{abiertos} en este espacio.
\end{definition}

En Lean, esta definición se escribe como una estructura que consta de cuatro elementos:

\begin{lstlisting}
  class TopologicalSpace (X : Type u) where
    IsOpen : Set X → Prop
    isOpen_univ : IsOpen Set.univ
    isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)
    isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)
\end{lstlisting}

El primer elemento, \code{IsOpen}, es una función que lleva cada conjunto de $X$ en una proposición, es decir, es una descripción de los elementos de $\mathcal{T}$ como el conjunto \code{\{U $\in$ Set (X) | IsOpen U\}}. Los otros tres elementos son demostraciones de las propiedades de la definición.

Veamos algunos ejemplos y sus demostraciones en Lean.

\begin{example}\label{ex:topologia-discreta}
    Sea $X$ un conjunto cualquiera. Consideremos la colección de todos los subconjuntos de $X$, $\mathcal{T} = \mathcal{P}(X)$. Entonces $\mathcal{T}$ es una topología sobre $X$, a la que llamamos \textnormal{topología discreta}.
\end{example}

\begin{proof}
  Podemos describir $\mathcal T$ como \code{\{U $\in$ Set (X) | true\}}, porque \code{IsOpen} es cierto para cualquier $U$.

  \begin{lstlisting}
  def DiscreteTopo (X : Type) : TopologicalSpace X where
    IsOpen (_ : Set X) := true \end{lstlisting}
  
  Ahora, demostrar el resto de propiedades es sencillo:

  \begin{minipage}[t]{0.58\textwidth}
\begin{lstlisting}[language=lean]
    isOpen_univ := by
  ~
\end{lstlisting}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.40\textwidth}
\begin{lstlisting}[language=infoview]
  ⊢ (fun x ↦ true = true) Set.univ
\end{lstlisting}
\end{minipage}

Aplicar la función \code{fun x $\mapsto$ true} a cualquier conjunto retorna siempre \code{true}, por tanto basta con usar \bluecode{trivial}.

\begin{lstlisting}
  def DiscreteTopo (X : Type) : TopologicalSpace X where
    IsOpen (_ : Set X) := true
    isOpen_univ := by
      trivial
    isOpen_inter := by
      intros
      trivial
    isOpen_sUnion := by
      intros
      trivial
\end{lstlisting}

\end{proof}


\begin{example}\label{ex:topologia-trivial}
    Sea $X$ un conjunto cualquiera. Consideremos la colección $\mathcal{T}=\{\emptyset, X\}$. Entonces $\mathcal{T}$ es una topología sobre $X$, a la que llamamos \textnormal{topología trivial}.
\end{example}

\begin{proof}
  Podemos describir $\mathcal{T}$ como \code{\{U $\in$ Set (X) | U = X $\lor$ U = $\emptyset$\}}.

  \begin{lstlisting}
  def TrivialTopology (X : Type) : TopologicalSpace X where
    IsOpen (s : Set X) := s = Set.univ ∨ s = ∅ \end{lstlisting}

  La primera condición se cumple trivialmente: queremos ver $X = X \lor X = \emptyset$.

  \begin{lstlisting}
    isOpen_univ := by
      left -- elegimos X = X
      rfl\end{lstlisting}

  Consideremos ahora dos abiertos (\bluecode{intro}). Diferenciamos en casos:

  \begin{lstlisting}
    isOpen_inter := by
      intro s t hs ht
      cases' hs with hs_univ hs_empty
      cases' ht with ht_univ ht_empty \end{lstlisting}

  Si ambos son $X$, la intersección será $X$ y por tanto abierta. Si uno de los dos es vacío, entonces la intersección es vacía, también abierta.

  \begin{lstlisting}
      · left -- s, t = Set.univ, s ∩ t = Set.univ ?
        rw [hs_univ, ht_univ]
        simp
      · right -- t = ∅, s ∩ t = ∅ ?
        rw [ht_empty]
        simp
      · right -- s = ∅, s ∩ t = ∅ ?
        rw [hs_empty]
        simp \end{lstlisting}

  Consideremos finalmente una colección arbitraria $S$ de abiertos. Para ver si la unión es abierta, consideramos dos casos distintos: o bien $X$ está en $S$, en cuyo caso la unión es $X$, o bien no lo está, en cuyo caso todos los conjuntos de $S$ son el vacío y la unión también lo es.

  \begin{lstlisting}
    isOpen_sUnion := by
      intro S hS
      cases' Classical.em (Set.univ ∈ S) with h1 h2

      · left -- h1 : Set.univ ∈ S, ⋃₀S = Set.univ ?
        ext s
        constructor
        · intro hs -- hs : s ∈ S, s ∈ Set.univ ?
          trivial
        · intro hs -- hs : s ∈ Set.univ, s ∈ S ?
          use Set.univ -- utiliza h1 implicitamente

      · right -- h2 : Set.univ ∉ S, ⋃₀S = ∅ ?
        simp -- ∀ s ∈ S, s = ∅ ?
        intro s hs
        specialize hS s hs -- aplicar definicion de abierto
        cases' hS with hS hS -- dividir en casos
        · by_contra -- si s = Set.univ, contradiccion
          rw [hS] at hs 
          exact h2 hs -- porque s ∈ S, pero Set.univ ∉ S
        · exact hS -- si s = ∅ \end{lstlisting}
\end{proof}


\begin{example}

  Consideremos la recta real y la definición usual de conjunto abierto en $\mathbb{R}$, es decir, $A \subseteq \mathbb{R}$ es abierto si y solo si para cada punto $x \in A$ existe una bola abierta centrada en $x$ enteramente contenida en $A$. Sea $\mathcal{T}$ la colección de estos abiertos. Entonces $\mathcal{T}$ es una topología sobre $\mathbb{R}$, a la que llamamos \textnormal{topología usual}.
\end{example}

\begin{proof}
  En Lean, podemos describir este espacio topológico dando sus elementos de la siguiente forma, donde cada objeto esta definido anteriormente.

  
  \begin{lstlisting}
  def UsualTopology : TopologicalSpace ℝ where
    IsOpen := Real.IsOpen
    isOpen_univ := Real.isOpen_univ
    isOpen_inter := Real.isOpen_inter
    isOpen_sUnion := Real.isOpen_sUnion \end{lstlisting}
  
  La definición de abierto se puede escribir así:

  \begin{lstlisting}
  def Real.IsOpen (s : Set ℝ) : Prop :=
    ∀ x ∈ s, ∃ δ > 0, ∀ y : ℝ, x - δ < y ∧ y < x + δ → y ∈ s \end{lstlisting}

  Damos la demostración para la intersección finita. El resto utilizan mecanismos parecidos.

  Sean por tanto dos subconjuntos $s$ y $t$ de $\mathcal{T}$. Sea $x \in t \cap s$ y queremos ver que existe una bola abierta centrada en $x$ y contenida en $t \cap s$.

  \begin{lstlisting}
  lemma Real.isOpen_inter (s t : Set ℝ)
      (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s ∩ t) := by
    intro x hx -- x ∈ s ∩ t, ∃ δ > 0, ∀ (y : ℝ), ... → y ∈ s ∩ t ? \end{lstlisting}

  Puesto que $x \in s$, existe un $\delta_1>0$ (\code{h$\delta$1}) de forma que $B_{\delta_1}(x) \subseteq s$ (\code{hs}). Análogamente, existe un $\delta_2>0$ (\code{h$\delta$2}) de forma que $B_{\delta_2}(x) \subseteq t$ (\code{ht}). Basta con tomar $\delta = \min \{\delta_1, \delta_2\}$.

  \begin{lstlisting}
    obtain ⟨δ1, hδ1, hs⟩ := hs x hx.left
    obtain ⟨δ2, hδ2, ht⟩ := ht x hx.right
    use min δ1 δ2 \end{lstlisting}

  Trivialmente $\delta > 0$.
  
  \begin{lstlisting}
    constructor
    · exact lt_min hδ1 hδ2 \end{lstlisting}

  Para ver que $B_\delta (x) \subseteq s \cap t$, consideramos $y \in B_\delta(x)$ y queremos ver que $y \in s$ y que $y \in t$. Para ver $y \in s$, como $B_{\delta_1}(x) \subseteq s$ (\code{hs}), basta ver $y \in B_{\delta_1}(x)$.

  \begin{lstlisting}
    · intro y hy
      constructor
      · apply hs -- x - δ1 < y ∧ y < x + δ1 ? \end{lstlisting}

  En realidad, esta condición se reduce a dos inecuaciones, que son fáciles de probar contando con que $\delta \leq \delta_1$ (\code{h$\delta$}).

  \begin{lstlisting}
      have hδ := min_le_left δ1 δ2
      constructor
      all_goals linarith \end{lstlisting}

  Probar que $y \in t$ es análogo.
  
\end{proof}


\subsubsection{Conjuntos abiertos}

Como hemos dicho, los conjuntos abiertos en un espacio topológico son los elementos de la topología. En Lean, es una función \code{TopologicalSpace.IsOpen} de tipo \code{Set X $\to$ \blue{Prop}}. Podemos utilizar esta definición directamente para demostrar que un abierto lo es.

\begin{example} 
    Por definición, el universo, $X$, siempre es abierto. En efecto:
\end{example}

\begin{lstlisting}
  example (X : Type) [T : TopologicalSpace X] : T.IsOpen Set.univ := by
    exact TopologicalSpace.isOpen_univ \end{lstlisting}

\begin{example}
  En la Definición \ref{def:espacio-topologico}, teníamos la condición $\emptyset \in \mathcal{T}$, condición que no aparece en la definición de Mathlib.

  Se puede probar que el vacío es abierto a partir del resto de condiciones: podemos escribir $\emptyset$ como $\emptyset = \bigcup_{x \in \emptyset} \{x\}$. Aplicando que la unión arbitraria de abiertos es abierta, bastaría ver que $\forall x \in \emptyset$, $\{x\}$ es un conjunto abierto. Lo cual es trivial.
\end{example}

\begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] :
      IsOpen (∅ : Set X) := by
    rw [← Set.sUnion_empty] -- ∅ = ⋃₀ ∅
    apply isOpen_sUnion
    intro t ht -- ht : t ∈ ∅, IsOpen t ?
    exfalso
    exact ht -- t ∈ ∅ = False
\end{lstlisting}


  
\begin{example}\label{ejemplo:intervalos-abiertos}
  En la topología usual, $(\mathbb{R}, \mathcal{T}_u)$, los intervalos abiertos $I = (a, b)$ con $a < b$ son abiertos de la topología.
\end{example}



\begin{proof}
  Consideremos un intervalo de la forma $(a, b)$ y queremos ver que es abierto. Para ello, sea $x \in (a, b)$, y veamos que existe un $\delta >0$ tal que $\forall y \in \mathbb{R}$, si $y \in B_\delta(x)$ entonces $y \in (a, b)$.

  \begin{lstlisting}
  lemma ioo_open_in_R (a b : ℝ) :
      UsualTopology.IsOpen ((Set.Ioo a b) : Set ℝ) := by
    rw [UsualTopology]
    intro x hx \end{lstlisting}

  Tomamos $\delta = min \{x-a, b-x\}$. Obviamente $\delta >0$ pues $a < x < b$.

  \begin{lstlisting}
    use min (x-a) (b-x)  -- nuestro δ
    constructor
    · simp
      exact hx \end{lstlisting}

  Sea ahora $y \in B_\delta(x)$ y queremos ver que $y \in (a, b)$. Hay dos posibles casos, según el valor que tome $\delta$. Si $\delta = x-a$, es decir, $x-a < b -x$, entonces se tiene
  $$
  y \in B_\delta(x) \implies x - (x - a) < y < x + (x - a) < x + (b - x) \implies a < y < b,
  $$
  luego $y \in (a, b)$. El caso $\delta = b -x$ es análogo.

  \begin{lstlisting}
    · intro y hy
      have cases := lt_or_le (x - a) (b - x)
      cases' cases with h h -- dividimos en casos
      all_goals -- aunque en ambos casos se procede igual
        try rw [min_eq_left_of_lt h] at hy
        try rw [min_eq_right h] at hy
        simp at hy
        constructor
        all_goals linarith \end{lstlisting}
\end{proof}

\begin{definition}[\textbf{Entorno abierto}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $x \in X$. Un \textnormal{entorno abierto} de $x$ en $X$ es un conjunto abierto $U \in \mathcal{T}$ de forma que $x \in U$.
\end{definition}

\begin{lstlisting}
  def OpenNeighbourhood {X : Type} [TopologicalSpace X]
    (U : Set X) (x : X) : Prop :=
    x ∈ U ∧ IsOpen U
\end{lstlisting}

\begin{example}
  El universo, $X$, es entorno abierto de cualquier punto $x \in X$. En efecto:
\end{example}

\begin{lstlisting}
  example {X : Type} [TopologicalSpace X] (x : X) :
      OpenNeighbourhood Set.univ x := by
    constructor
    · trivial -- x ∈ Set.univ ?
    · exact isOpen_univ -- IsOpen Set.univ ? \end{lstlisting}

\begin{definition}[\textbf{Entorno}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $x \in X$. Un \textnormal{entorno} de $x$ en $X$ es un conjunto $V \subseteq X$ de forma que existe un entorno abierto de $x$, $U \in \mathcal{T}$, con $U \subseteq V$.
\end{definition}

\begin{lstlisting}
  def Neighbourhood {X : Type} [TopologicalSpace X]
    (V : Set X) (x : X) : Prop :=
    ∃ U : Set X, U ⊆ V ∧ OpenNeighbourhood U x
\end{lstlisting}

\begin{example}
  Un entorno abierto es también un entorno. En efecto:
\end{example}

\begin{lstlisting}
  example {X : Type} [TopologicalSpace X] (U : Set X) (x : X) :
      OpenNeighbourhood U x → Neighbourhood U x := by
    intro hU
    use U -- usamos el propio U como abierto,
        -- lo que completa la prueba directamente
\end{lstlisting}

\begin{proposition}[\textbf{Caracterización de conjuntos abiertos}]\label{caracterizacion-abierto}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq U$ un conjunto cualquiera. $A$ es abierto si y solo si es entorno de todos sus puntos.
\end{proposition}

\begin{lstlisting}
  lemma A_open_iff_neighbourhood_of_all {X : Type}
      [T : TopologicalSpace X] {A : Set X} :
      IsOpen A ↔ ∀ x ∈ A, Neighbourhood A x := by
\end{lstlisting}

\begin{proof}
  Demostramos cada implicación separadamente.

  \begin{lstlisting}
    constructor; all_goals intro h \end{lstlisting}

  $(\implies)$ La primera implicación es sencilla: si $A$ es abierto, para cada $x \in A$ basta tomar $A$ como entorno de $x$.

  \begin{lstlisting}
    · intro x hx -- hx : x ∈ A
      use A
      constructor
      · trivial -- A ⊆ A
      · constructor
        · exact hx -- x ∈ A
        · exact h -- IsOpen A \end{lstlisting}

  $(\impliedby)$ El recíproco es más complicado. Sabemos que para cada $a \in A$ existe $U_a$ entorno de $a$. Primero probaremos que
  $$
  A = \bigcup_{a \in A} U_a
  $$
  \begin{lstlisting}
    · have hUnion : A = ⋃ x : A, Classical.choose (h x x.property) \end{lstlisting}
  Para ello, probamos ambas inclusiones. Si $x \in A$, entonces por nuestra hipótesis existe un entorno de $x$, $U_x$. Y por la definición de entorno, eso quiere decir que $x \in U_x$. Luego $x \in \bigcup_{a}U_a$.

  \begin{lstlisting}
      · ext x; constructor; all_goals intro hx
        · have ⟨_, hUx⟩  := Classical.choose_spec (h x hx)
           -- hUx : OpenNeigh. Ux x
          simp -- ∃ a ∈ A, x ∈ Ua ?
          use x, hx
          exact hUx.left -- x ∈ Ux \end{lstlisting}

  Ahora, si $x \in \bigcup_{a}U_a$, entonces existe un $a \in A$ con $x \in U_a$ y $U_a$ entorno abierto de $a$ con $U_a \subseteq A$. Luego $x \in U_a \subseteq A$.

  \begin{lstlisting}
        · simp at hx
          obtain ⟨a, ha, hx⟩ := hx -- hx : x ∈ Ua
          have ⟨ha', _⟩ := Classical.choose_spec (h a ha)
            -- ha' : Ua ⊆ A
          apply ha'
          exact hx \end{lstlisting}
  
  Entonces hemos probado que $A$ se expresa como una unión de conjuntos $U_a$. Pero sabemos que todos estos conjuntos son entornos abiertos, luego son abiertos. Basta aplicar que la unión de abiertos es abierta.

  \begin{lstlisting}
      rw [hUnion]
      apply isOpen_iUnion
      intro a
      exact (Classical.choose_spec (h a a.property)).right.right \end{lstlisting}
\end{proof}

\newpage

\begin{definition}[\textbf{Interior}]
    Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Definimos el \textnormal{interior} como el conjunto
    $$
    \overset{\circ}{A} = \bigcup \left\{ U \subseteq X | U \text{ es abierto y } U \subseteq A \right\}
    $$
\end{definition}

\begin{lstlisting}
  def interior (s : Set X) : Set X :=
    ⋃₀ { t | IsOpen t ∧ t ⊆ s }
\end{lstlisting}

Veamos varias propiedades del interior de un conjunto.

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces
  $$
  \overset{\circ}{A} \subseteq A
  $$
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{interior\_subset}.

\begin{proof}
  Sea $a \in \overset{\circ}{A}$. Entonces $A$ es entorno de $a$ y existe un abierto con $a \in U \subseteq A$. Luego $a \in A$.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      interior A ⊆ A := by
    intro a ha
    obtain ⟨U, hU, ha⟩ := ha -- hU : IsOpen U ∧ U ⊆ A, ha : a ∈ U
    apply hU.right
    exact ha \end{lstlisting}
\end{proof}

\begin{proposition}
    Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $\overset{\circ}{A}$ es un conjunto abierto.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{isOpen\_interior}.

\begin{proof}
  Por la caracterización de conjuntos abiertos \pref{caracterizacion-abierto}, basta ver que dado $a \in \overset{\circ}{A}$, $\overset{\circ}{A}$ es entorno de $a$.
  
  Si $a \in \overset{\circ}{A}$, entonces existe abierto $U$ con $a \in U \subseteq A$. Usamos este $U$ para demostrar que $\overset{\circ}{A}$ es entorno de $a$.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsOpen (interior A) := by
    apply A_open_iff_neighbourhood_of_all.mpr
    intro a ha
    obtain ⟨U, hU, ha⟩ := ha -- hU : IsOpen U ∧ U ⊆ A, ha : a ∈ U
    use U
    constructor
    · intro x hx -- U ⊆ interior A ?
      use U
    · constructor
      · exact ha -- a ∈ U
      · exact hU.left -- IsOpen U \end{lstlisting}
\end{proof}


\begin{proposition}
    Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $A$ es abierto si y solo si $A$ es igual a su interior.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{interior\_eq\_iff\_isOpen}.

\begin{proof}
  El recíproco es trivial, pues ya hemos visto que el interior de un conjunto es abierto.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsOpen A ↔ interior A = A:= by
    constructor; swap; all_goals intro h
    · rw [← h]
      exact isOpen_interior \end{lstlisting}

  Ahora, supongamos que $A$ es abierto. Ya hemos visto que $\overset{\circ}{A} \subseteq A$, luego basta ver el otro contenido. Sea $a \in A$. Como $A$ es abierto, es un entorno abierto de $a$ con $A \subseteq A$. Luego $a \in \overset{\circ}{A}$.
  
  \begin{lstlisting}
    · apply Set.Subset.antisymm
      · exact interior_subset
      · intro a ha
        use A
        constructor
        · simp
          exact h
        · exact ha \end{lstlisting}
\end{proof}


\subsubsection{Conjuntos cerrados}

\begin{definition}[\textbf{Conjunto cerrado}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Decimos que $A$ es \textnormal{cerrado} en $X$ si $A^c$ es abierto en $X$.
\end{definition}

\begin{lstlisting}
  class IsClosed (s : Set X) : Prop where
    isOpen_compl : IsOpen sᶜ
\end{lstlisting}

\begin{example}
  El universo es cerrado, porque el vacío es abierto. El vacío es cerrado, porque el universo es cerrado.
\end{example}

\begin{lstlisting}
  example (X : Type) [TopologicalSpace X] :
      IsClosed (Set.univ : Set X) := by
    rw [← isOpen_compl_iff] -- IsOpen Xᶜ ?
    rw [Set.compl_univ] -- IsOpen ∅ ?
    exact isOpen_empty
\end{lstlisting}

\begin{example}
  La intersección arbitraria de cerrados es cerrada. La unión finita de cerrados es cerrada. Ambas se deducen de manera sencilla de la definición de espacio topológico y de conjunto cerrado.
\end{example}

\begin{lstlisting}
  example (X : Type) [TopologicalSpace X] (A B : Set X) (hA : IsClosed A)
      (hB : IsClosed B) : IsClosed (A ∪ B) := by
  rw [← isOpen_compl_iff] at *
  rw [Set.compl_union] -- usar (A ∪ B)ᶜ = (Aᶜ ∩ Bᶜ)
  apply TopologicalSpace.isOpen_inter
  exact hA
  exact hB
\end{lstlisting}

\begin{definition}[\textbf{Clausura}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Definimos la \textnormal{clausura} de $A$ como el conjunto
  $$
  \overline{A} = \bigcap \{K \subseteq X | K \text{ es cerrado y } A \subseteq K\}
  $$
\end{definition}

\begin{lstlisting}
  def closure (s : Set X) : Set X :=
    ⋂₀ { t | IsClosed t ∧ s ⊆ t }
\end{lstlisting}

Veamos algunas propiedades de la clausura de un conjunto.

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces
  $$
  A \subseteq \overline{A}
  $$
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{subset\_closure}.

\begin{proof}
  Sea $a \in A$ y queremos ver que $a \in \overline{A}$. Como $\overline{A}$ es una intersección, esto es equivalente a probar que para cada $K$ cerrado con $A \subseteq K$, $x \in K$. Pero esto es trivial porque, para cada uno de esos $K$, $x \in A \subseteq K$.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      A ⊆ closure A := by
    intro x hx
    intro K hK -- hK : IsClosed K ∧ A ⊆ K; x ∈ K ?
    apply hK.right -- x ∈ A ?
    exact hx \end{lstlisting}
\end{proof}

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces
  $$
  (\overline{A})^c = \overset{\circ}{\overbrace{(A^c)}} 
  $$
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{interior\_compl}.

\begin{proof}
  Veamos ambos contenidos por separado.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      (closure A)ᶜ = interior (Aᶜ) := by
    ext x; constructor; all_goals intro hx \end{lstlisting}
  
  $(\subseteq)$ Supongamos que $x \in (\overline{A})^c$, es decir $x \notin \overline{A}$. Esto quiere decir que existe un $K$ cerrado de forma que $A \subseteq K$ y $x \notin K$.

  \begin{lstlisting}
    · simp [closure] at hx
      obtain ⟨K, hKclosed, hKA, hKx⟩ := hx -- hKx : x ∉ K \end{lstlisting}
  
  Para ver que $x$ está en el interior de $A^c$, queremos ver que existe un abierto contenido en $A^c$ que contiene a $x$. Consideremos el abierto $K^c$. Como $A \subseteq K$, se tiene $K^c \subseteq A^c$, y como $x \notin K$, se tiene $x \in K^c$

  \begin{lstlisting}
      use Kᶜ 
      constructor
      · constructor
        · exact isOpen_compl_iff.mpr hKclosed -- IsOpen Kᶜ
        · exact Set.compl_subset_compl_of_subset hKA -- Kᶜ ⊆ Aᶜ
      · exact hKx -- x ∈ Kᶜ \end{lstlisting}

  $(\supseteq)$ Sea $x$ en el interior de $A^c$. Entonces existe un abierto $U$ con $x \in U \subseteq A^c$. Para ver que $x$ está en el complementario de $\overline{A}$, supongamos, por reducción al absurdo, que $x \in \overline{A}$.

  \begin{lstlisting}
    · obtain ⟨U, hU, hUx⟩ := hx
      obtain ⟨hUopen, hUA⟩ := hU
      by_contra hx -- hx : x ∈ closure A \end{lstlisting}

  En ese caso, para cada $K$ cerrado con $A \subseteq K$, se tiene $x \in K$. En particular, como $U^c$ es cerrado por ser $U$ abierto y tiene $A \subseteq U^c$ por ser $U \subseteq A^c$, se tiene que $x \in U^c$. Pero $x \in U$, lo cual es una contradicción.

  \begin{lstlisting}
      simp [closure] at hx
      specialize hx Uᶜ
        (by exact isClosed_compl_iff.mpr hUopen)
        (by exact Set.subset_compl_comm.mp hUA)
      exact hx hUx \end{lstlisting}
\end{proof}

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $\overline{A}$ es un conjunto cerrado.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{isClosed\_closure}.

\begin{proof}
  La prueba es sencilla utilizando el resultado anterior: $\overline{A}$ es cerrado si $(\overline{A})^c$ es abierto. Pero hemos visto que $(\overline{A})^c = (A^c)^\circ$, y el interior de cualquier conjunto es abierto.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsClosed (closure A) := by
    apply isOpen_compl_iff.mp -- IsOpen (closure A)ᶜ ?
    rw [← interior_compl] -- IsOpen (interior Aᶜ) ?
    exact isOpen_interior \end{lstlisting}
\end{proof}

\begin{proposition}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$. Entonces $A$ es cerrado si y solo si es igual a su clausura.
\end{proposition}

\begin{proof}
  El recíproco es trivial, pues ya hemos visto que la clausura de un conjunto es cerrada.

  \begin{lstlisting}
  example {X : Type} [T : TopologicalSpace X] (A : Set X) :
      IsClosed A ↔ closure A = A := by
    constructor; swap; all_goals intro h
    · rw [← h]
      exact isClosed_closure \end{lstlisting}

  Ahora, supongamos que $A$ es cerrado. Entonces $A^c$ es abierto, luego es igual a su interior. Pero el interior de $A^c$ hemos visto que es $(\overline{A})^c$, luego $A^c = (\overline{A})^c$, de lo que se deduce $A = \overline{A}$.

  \begin{lstlisting}
    · rw [← isOpen_compl_iff, ← interior_eq_iff_isOpen, interior_compl] at h
      rw [← compl_compl A, ← h, compl_compl]
      exact closure_closure \end{lstlisting}
  
\end{proof}


\subsection{Bases}

\begin{definition}
  Sea $\mathcal{T}$ una topología. Una \textnormal{base de la topología} $\mathcal{T}$ es una colección de abiertos $\mathcal{B} \subset \mathcal{T}$ de forma que cada abierto de $\mathcal{T}$ es unión de abiertos de $\mathcal{B}$\footnote{Hay varias formas de dar esta definición, esta es la que yo he elegido para definirla en Lean, de manera independiente a Mathlib. Por tanto, los resultados de esta sección no se encuentran literalmente en Mathlib.}.
\end{definition}

\begin{lstlisting}
  def isTopoBase {X : Type} [TopologicalSpace X]
      (B : Set (Set X)) : Prop :=
    (∀ U ∈ B, IsOpen U) ∧
    (∀ V : Set X, IsOpen V → ∃ UB ⊆ B, V = ⋃₀ UB)
\end{lstlisting}

\begin{example}
  El conjunto de los intervalos abiertos en $\mathbb{R}$,
  $$
  \mathcal{B} = \left\{ I = (a, b) ~|~ a < b\right\},
  $$
  es una base de la topología usual $(\mathbb{R}, \mathcal{T}_u)$.
\end{example}

\begin{proof}

  Hemos visto que los intervalos abiertos son abiertos en la topología usual (Ejemplo \ref{ejemplo:intervalos-abiertos}). Por tanto la primera parte de la definición de base ya la tenemos.

  \begin{lstlisting}
  lemma BaseOfRealTopo [T : TopologicalSpace ℝ] (hT : T = UsualTopology) :
      isTopoBase {s | ∃ a b : ℝ, s = Set.Ioo a b} := by
    constructor
    · intro U hU -- sea U en el conjunto
      obtain ⟨a, b, hU⟩ := hU -- hU : U = (a, b)
      rw [hU, hT]
      exact ioo_open_in_R a b -- aplicamos el resultado anterior \end{lstlisting}

  Ahora, para la segunda parte, consideramos un $U \subseteq X$ cualquiera. Queremos ver que se escribe como unión de intervalos abiertos.

  \begin{lstlisting}
    · intro U hUopen
      rw [hT] at hUopen \end{lstlisting}
  
  Para ello, consideremos para cada $x \in U$, el $\delta_u$ resultante de aplicar la definición de abierto, es decir, tal que $B_{\delta_x}(x) \subseteq U$. Queremos demostrar que $U = \bigcup \{B_{\delta_x}(x) | x \in U\}$, y que este es un subconjunto de $\mathcal{B}$.

  \begin{lstlisting}
      let δ : U → ℝ := fun x ↦ Classical.choose (hUopen x x.property)
      have δspec : ∀ x : U, 0 < δ x
          ∧ ∀ y : ℝ, ↑x - δ x < y ∧ y < ↑x + δ x → y ∈ U :=
        fun x ↦ Classical.choose_spec (hUopen x (x.property))

      use {s | ∃ x, s = Set.Ioo (x - δ x) (x + δ x)} \end{lstlisting}

  Obviamente, es un subconjunto de $\mathcal{B}$ puesto que es un conjunto formado por intervalos abiertos.

  \begin{lstlisting}
      constructor
      · intro V hV
        obtain ⟨x, hV⟩ := hV
        use (↑x - δ x), (↑x + δ x) \end{lstlisting}

  Ahora, para ver que $U = \bigcup \{B_{\delta_x}(x) | x \in U\}$, demostramos las dos inclusiones de manera separada.

  \begin{lstlisting}
      · ext u; constructor; all_goals intro hu \end{lstlisting}

  $(\subseteq)$ Sea $u \in U$. Entonces $u \in B_{\delta_u}$ trivialmente. Luego está en la unión.

  \begin{lstlisting}
        · use Set.Ioo (↑u - δ ⟨u, hu⟩) (↑u + δ ⟨u, hu⟩) -- = Bδu(u)
          constructor
          · simp -- Bδu(u) es un intervalo abierto ?
            use u, hu
          · simp -- u ∈ Bδu(u) ?
            exact (δspec ⟨u, hu⟩).left \end{lstlisting}

  $(\supseteq)$ Sea $u \in \bigcup \{B_{\delta_x}(x) | x \in U\}$. Entonces existe un $v \in U$ de forma que $u \in B_{\delta_v}(v) \subseteq U$. Luego $u \in U$.

  \begin{lstlisting}
        · obtain ⟨I, hI, hu⟩ := hu
          obtain ⟨v, hI⟩ := hI
          rw [hI] at hu
          exact (δspec v).right u hu \end{lstlisting}
  
\end{proof}

\subsection{Topología relativa}

\begin{definition}[\textbf{Topología relativa}]
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$ un subconjunto. Entonces la colección
  $$
  \mathcal{T}|_A = \{U \cap A | U \in \mathcal{T}\}
  $$
  es una topología sobre $A$, llamada la \textnormal{topología relativa} a $X$ de $A$.

  Diremos que $(A, \mathcal{T}|_A)$ es un \textnormal{subespacio topológico} de $(X, \mathcal{T})$.
\end{definition}

En Lean, para poder utilizar esta definición, tenemos que demostrar que este conjunto es, en efecto, una topología.

\begin{proof}
  Sea $(X, \mathcal{T})$ un espacio topológico y $A \subseteq X$ un subconjunto, y definimos la colección
  $$
  \mathcal{T}|_A = \{U \cap A | U \in \mathcal{T}\}
  $$

  \begin{lstlisting}
  def TopoSubspace {X : Type} (T : TopologicalSpace X) (Y : Set X) :
      TopologicalSpace Y where
    IsOpen (V : Set Y) := ∃ U : Set X, T.IsOpen U ∧ V = U ∩ Y \end{lstlisting}
  
  (1) El universo es abierto. En efecto, pues $A = X \cap A$ y $X$ es abierto en $X$.
  
  \begin{lstlisting}
    isOpen_univ := by
      use (Set.univ : Set X)
      constructor
      · exact T.isOpen_univ
      · simp \end{lstlisting}
  
  (2) Sean $V_1$ y $V_2$ abiertos en $A$. Entonces $V_1 = U_1 \cap A$ y $V_2 = U_2 \cap A$ con $U_1, U_2$ abiertos en $X$. Luego
  $$
  V_1 \cap V_2 = (U_1 \cap A) \cap (U_2 \cap A) = (U_1 \cap U_2) \cap A,
  $$
  y $U_1 \cap U_2$ es abierto en $X$ por la segunda propiedad.

  \begin{lstlisting}
    isOpen_inter := by
      intro V1 V2 h1 h2
      obtain ⟨U1, h1open, h1inter⟩ := h1
      obtain ⟨U2, h2open, h2inter⟩ := h2
      use U1 ∩ U2
      constructor
      · exact T.isOpen_inter U1 U2 h1open h2open
      · simp
        rw [h1inter, h2inter]
        exact Eq.symm (Set.inter_inter_distrib_right U1 U2 Y) \end{lstlisting}
  
  (3) Sea $S = \{V_i\}_i$ una colección de abiertos en $A$. Entonces, para cada $V_i$ existe un $U_i$ abierto en $X$ de forma que $V_i = U_i \cap A$. Entonces
  $$
  \bigcup S = \bigcup_{i}V_i = \bigcup_{i}(U_i \cap A) = A \cap \bigcup_{i}U_i,
  $$
  y $\bigcup_{i}U_i$ es abierto en $X$ por la tercera propiedad.

  Se deja la demostración en Lean para el anexo porque es más complicada.
\end{proof}

\begin{example}
  Consideremos $\mathbb{R}$ con la topología usual y el intervalo $[0, 1] \subset \mathbb{R}$. En la topología de $[0, 1]$ inducida por la topología usual, los intervalos de la forma $[0, b)$ son abiertos para todo $0 < b \leq 1$ (aunque no lo sean en $\mathbb{R}$). También son abiertos los intervalos de la forma $(a, 1]$ para cada $0 \leq a < 1$.
\end{example}

\begin{proof}
  Para cada $b > 0$, basta con usar por ejemplo el intervalo abierto $(-1, b)$. Ya hemos visto que los intervalos abiertos son abiertos en $\mathbb{R}$, y se tiene $(-1, b) \cap [0, 1] = [0, b)$. Luego $[0, b)$ es abierto en $[0, 1]$.

  \begin{lstlisting}
  lemma ico_open_in_Icc01 {Y : Set ℝ} {hY : Y = Set.Icc 0 1}
      {R : TopologicalSpace Y} {hR : R = TopoSubspace UsualTopology Y}
      (b : ℝ) (hb : 0 < b ∧ b < 1) :
      R.IsOpen ({y | (y : ℝ) ∈ Set.Ico 0 b} : Set Y) := by

  rw [hR] -- usar la topologia relativa
  rw [UsualTopology] -- usar la def. de topologia usual
  use ((Set.Ioo (-1) b) : Set ℝ) -- usar [-1, b)
  constructor
  · exact ioo_open_in_R (-1) b -- es abierto
  · ext x; constructor -- (-1, b) ∩ [0, 1] = [0, b) ?
    all_goals
      intro hx
      simp at * -- convertirlo todo a inecuaciones
      constructor
      · simp [hY] at hx
        constructor
        all_goals linarith
      · exact hx.right \end{lstlisting}
\end{proof}


\subsection{Continuidad}

\begin{definition}
  Sean $X$ e $Y$ dos espacios topológicos y $f : X \to Y$ una función entre ambos. Entonces $f$ es \textnormal{continua} en un punto $x_0 \in X$ si para cada entorno $V$ de $f(x_0)$ en $Y$, se tiene que $f^{-1}(V)$ es entorno de $x_0$ en $X$. Diremos que $f$ es \textnormal{continua} en $X$ si es continua en cada punto.
\end{definition}

\begin{proposition}[\textbf{Caracterización de funciones continuas}]
  Sean $X$ e $Y$ dos espacios topológicos y $f : X \to Y$ una función entre ambos. Entonces $f$ es continua si y solo si para cada $V \subseteq Y$ abierto, se tiene que $f^{-1}(V)$ es abierto en $X$.
\end{proposition}

\begin{proof} Veamos ambas implicaciones por separado.

  \begin{lstlisting}
  example (X Y : Type) [TopologicalSpace X] [TopologicalSpace Y]
      (f : X → Y) :
      (∀ x : X, ∀ V : Set Y, Neighbourhood V (f x) →
        Neighbourhood (f ⁻¹' V) x)
      ↔ ∀ (V : Set Y), IsOpen V → IsOpen (f ⁻¹' V) := by
    constructor; all_goals intro h \end{lstlisting}

  $(\implies)$ Sea $f : X \to Y$ continua y sea $V \subseteq Y$ un conjunto abierto. Queremos ver que $f^{-1}(V)$ es abierto. Para ello, basta ver que es entorno de todos sus puntos (Prop. \ref{caracterizacion-abierto}).
  
  Sea $x \in f^{-1}(V)$. Entonces $V$ es entorno de $f(x)$, por ser $V$ un abierto con $f(x) \in V$. Luego, por la definición de continuidad, $f^{-1}(V)$ es entorno de $x$.

  \begin{lstlisting}
    · intro V hVopen
      apply A_open_iff_neighbourhood_of_all.mpr
      intro x hx
      exact h x V
        (by use V; simp; exact ⟨hx, hVopen⟩) -- V entorno de f x \end{lstlisting}

  $(\impliedby)$ Sea ahora $x \in X$ y $V \subseteq Y$ un entorno de $f(x)$ en $Y$. Queremos ver que $f^{-1}(V)$ es entorno de $x$ en $X$.
  
  Existe un entorno abierto $U\subseteq V$ de $f(x)$ en $Y$. Entonces $x \in f^{-1}(U)\subseteq f^{-1}(V)$, y es un abierto, por hipótesis. Por tanto $f^{-1}(V)$ es entorno de $x$.

  \begin{lstlisting}
    · intro x V hV
      obtain ⟨U, hUV, hU⟩ := hV
      obtain ⟨hUx, hUopen⟩ := hU
      use f ⁻¹' U
      constructor
      · intro u hu -- f ⁻¹' U ⊆ f ⁻¹' V ?
        apply hUV
        exact hu
      · constructor
        · exact hUx -- x ∈ f ⁻¹' U
        · exact h U hUopen -- IsOpen (f ⁻¹' U) \end{lstlisting}
  
\end{proof}

Puesto que ambas definiciones son equivalentes, en Mathlib se utiliza la segunda para definir las funciones continuas, y en general utilizaremos esta definición.

\begin{lstlisting}
  structure Continuous (f : X → Y) : Prop where
    isOpen_preimage : ∀ s, IsOpen s → IsOpen (f ⁻¹' s)
\end{lstlisting}

Utilizaremos \code{continuous\_def} para re escribir \code{Continuous f} por esta definición cuando lo necesitemos.

\begin{example}
  Sea $f : (X, \mathcal{T}_{disc}) \to (Y, \mathcal{T})$ una función en la que el espacio de salida tiene la topología discreta (Ej. \ref{ex:topologia-discreta}). Entonces $f$ es continua.

  Si tomamos cualquier abierto de $Y$, su preimagen será abierta en la topología discreta trivialmente, puesto que cualquier conjunto lo es.
\end{example}

\begin{lstlisting}
  lemma continuous_from_discrete {X Y : Type} [T : TopologicalSpace X]
      [TopologicalSpace Y] (h : T = DiscreteTopo X) (f : X → Y) : Continuous f := by
    rw [continuous_def]
    intro U _ -- ni si quiera importa si U es abierto
    rw [h, DiscreteTopo] -- utilizamos la def de topologia discreta
    trivial
\end{lstlisting}

\begin{example}
  Sea $f : (X, \mathcal{T}) \to (Y, \mathcal{T}_{trivial})$ una función en la que el espacio de llegada tiene la topología trivial (Ej. \ref{ex:topologia-trivial}). Entonces $f$ es continua.

  Puesto que las únicas posibilidades de abiertos a tomar en $Y$ son el propio $Y$ y el conjunto vacío, sus preimágenes serán respectivamente $X$ y el conjunto vacío, que son abiertos.
\end{example}

\begin{lstlisting}
  lemma continuous_to_trivial {X Y : Type} [TopologicalSpace X]
      [T : TopologicalSpace Y] (h : T = TrivialTopology Y) (f : X → Y) :
      Continuous f := by
    rw [continuous_def]
    intro U hU
    rw [h, TrivialTopology] at hU
    cases' hU with hUuniv hUempty
    · rw [hUuniv] -- si U = Y
      exact isOpen_univ
    · rw [hUempty] -- si U = ∅
      exact isOpen_empty
\end{lstlisting}

\begin{proposition}
  La composición de funciones continuas entre espacios topológicos es también una función continua.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{Continuous.comp}.

\begin{proof}
  Sean $f : X \to Y$ y $g : Y \to Z$ dos funciones continuas y consideremos su composición $g \circ f : X \to Z$.

  Sea $W$ un abierto de $Z$. Como $g$ es continua, $V = g^{-1}(W)$ es abierto en $Y$. Como $f$ es continua, $f^{-1}(V)$ es abierto en $X$. Pero
  $$
  f^{-1}(V) = f^{-1}(g^{-1}(W)) = (g \circ f)^{-1}(W)
  $$

  \begin{lstlisting}
  example (X Y Z : Type) [TopologicalSpace X] [TopologicalSpace Y]
      [TopologicalSpace Z] (f : X → Y) (g : Y → Z)
      (hf : Continuous f) (hg : Continuous g) : Continuous (g ∘ f) := by
    rw [continuous_def] at *
    intro W hW
    specialize hg W hW
    specialize hf (g ⁻¹' W) hg
    exact hf \end{lstlisting}
\end{proof}

\begin{proposition}[Caracterización de la continuidad por cerrados]
  Sean $X$ e $Y$ dos espacios topológicos y $f : X \to Y$ una función entre ambos. Entonces $f$ es continua si y solo si para cada $C \subseteq Y$ cerrado, se tiene que $f^{-1}(C)$ es cerrado en $X$.
\end{proposition}

En Mathlib, este resultado recibe el nombre de \code{continuous\_iff\_isClosed}.


\begin{proof}
  Supongamos que $f$ es continua. Sea $C$ cerrado en $Y$. Entonces $C^c$ es abierto en $Y$. Por ser $f$ continua, $f^-1(C^c)$ es abierto en $X$. Pero $f^-1(C^c) = f^-1(C)^c$, luego $f^-1(C)$ es cerrado en $X$. El recíproco es análogo.
  
  \begin{lstlisting}
  example (X Y : Type) [TopologicalSpace X] [TopologicalSpace Y]
      (f : X → Y) : Continuous f ↔
        ∀ C : Set Y, IsClosed C → IsClosed (f ⁻¹' C) := by
    constructor; all_goals intro h
    · rw [continuous_def] at h
      intro C hC
      rw [← isOpen_compl_iff] at *
      exact h Cᶜ hC
    · rw [continuous_def]
      intro U hU
      rw [← isClosed_compl_iff] at *
      exact h Uᶜ hU  \end{lstlisting}

\end{proof}

\begin{proposition}[Continuidad del subespacio]\label{prop:continuidad-subespacio}
  Sean $X$ e $Y$ espacios topológicos y $Z$ un subespacio topológico de Y. Una función $f : X \to Z$ es continua si y solo si lo es como función $f : X \to Y$.
\end{proposition}

Es decir, para demostrar la condición de continuidad de $f : X \to Z$, basta con tomar abiertos arbitrarios de $Y$.

\begin{proof}
  Veamos cada implicación por separado.

  \begin{lstlisting}
  lemma continuousInSubspace_iff_trueForSpace {X Y : Type} {Z : Set Y}
      [TX : TopologicalSpace X] [TY : TopologicalSpace Y]
      [TZ : TopologicalSpace Z] (hZ : TZ = TopoSubspace TY Z)
      (f : X → Z) : Continuous f ↔ ∀ U : Set Y,
        TY.IsOpen U → TX.IsOpen (f ⁻¹' (Subtype.val ⁻¹' U)) := by
    rw [continuous_def]
    constructor
    all_goals intro h U hU \end{lstlisting}

  $(\implies)$ Supongamos que $f : X \to Z$ es continua. Sea $U$ un abierto de $Y$ y queremos ver que $f^-1(U)$ es abierto en $X$. Puesto que $f$ es continua, basta ver que $f(f^{-1})(U)$ es abierto. Pero $f(f^{-1})(U) = U \cap Y$, que es abierto por la definición de topología relativa por ser $U$ abierto.

  \begin{lstlisting}
    · apply h
      rw [hZ]
      use U
      constructor
      · exact hU
      · simp
        exact Set.inter_comm Z U \end{lstlisting}

  $(\impliedby)$ Supongamos ahora que $f : X \to Y$ es continua. Sea $U$ un abierto en $Z$. Entonces, por la definición de la topología relativa, existe un $V$ abierto en $Y$ de forma que $U = V \cap Z$. Por ser $f$ continua, $f^{-1}(V)$ es abierto. Entonces $f^{-1}(U) = f^{-1}(V \cap Z) = f^{-1}(V)$, por ser $f : X \to Z$. Luego es abierto.

  \begin{lstlisting}
    · rw [hZ] at hU
      obtain ⟨V, hV⟩ := hU
      rw [← @Set.preimage_val_image_val_eq_self Y Z U, hV.right]
      simp
      apply h
      exact hV.left \end{lstlisting}
\end{proof}


\begin{proposition}\label{prop:continuous-base}
  Sea $f : X \to Y$ una función entre espacios topológicos y sea $\mathcal{B}$ una base de $Y$. Entonces $f$ es continua si y solo si para cada $U \in \mathcal{B}$ abierto básico, se tiene que $f^{-1}(U)$ es abierto en $X$.
\end{proposition}

Es decir, para la definición de continuidad de una función basta tomar los abiertos básicos.

\begin{lstlisting}
  lemma continuous_iff_trueForBasics {X Y : Type} [T : TopologicalSpace X]
      [T' : TopologicalSpace Y] (f : X → Y)
      (B : Set (Set Y)) (hB : isTopoBase B) :
      Continuous f ↔ ∀ U ∈ B, IsOpen (f ⁻¹' U)
\end{lstlisting}

\begin{proof}
  La primera implicación es trivial; si la propiedad de continuidad se cumple para cada abierto trivialmente se cumple para los abiertos básicos.

  \begin{lstlisting}
      rw [continuous_def]
      constructor; all_goals intro h
      · exact fun U hU ↦ h U (hB.left U hU) \end{lstlisting}

  $(\impliedby)$ Sea $V$ abierto en $Y$ y queremos ver que $f^{-1}(V)$ es abierto en $X$. Como $\mathcal{B}$ es base de $Y$, existe una familia $\{B_i\}_i \subseteq \mathcal{B}$ de forma que $U = \bigcup_i B_i$. Entonces $$
  f^{-1}(U) = f^{-1}\big(\bigcup_i B_i\big) = \bigcup_i f^{-1}(B_i),
  $$
  que será abierto cuando cada uno de los componentes de la unión sea abierto. Pero $B_i$ es abierto por pertenecer a una base, y $f$ es continua, luego $f^{-1}(B_i)$ es continuo para cada $i$.

  \begin{lstlisting}
    · intro V hV
      obtain ⟨UB, hUB⟩ := hB.right V hV
      rw [hUB.right, Set.preimage_sUnion]
      apply isOpen_biUnion
      intro A hA
      apply h
      exact (hUB.left hA) \end{lstlisting}

\end{proof}

Estos dos últimos resultados se pueden combinar, de manera que para demostrar que $f : X \to Z \subseteq Y$ es continua, basta con demostrar la condición para los abiertos básicos de $Y$. Este resultado, que he demostrado en Lean y llamado \code{continuousInSubspace\_iff\_trueForBase}, es uno de los que utilizaremos para demostrar la continuidad en el lema de Urysohn.


\subsection{Separación}

No cualquier topología sobre un conjunto refleja adecuadamente las propiedades de dicho conjunto. Por ejemplo, la topología trivial no permite diferenciar elementos del espacio, por lo que bajo esta topología no es posible diferenciar unos conjuntos de otros o incluso de un único punto.

Para profundizar en el estudio de la topología, se introducen ciertas condiciones que garantizan que los puntos del espacio puedan distinguirse de alguna forma mediante abiertos. Estas condiciones se conocen como axiomas de separación.

Por ejemplo, un espacio es de Hausdorff si dados dos puntos distintos, existen abiertos disjuntos que contienen a cada uno de ellos. Esta condición es cierta para cualquier espacio métrico, y garantiza ciertas propiedades buenas, como la unicidad de los límites.

En este trabajo nos centraremos, en particular, en los espacios normales.


\subsubsection{Espacios normales}

Los espacios normales permiten separar no solo puntos, sino conjuntos cerrados disjuntos mediante abiertos disjuntos. Esta propiedad es más exigente, pero también más potente.

Uno de las propiedades más importantes de los espacios normales es que nos permiten distinguir entre conjuntos cerrados separándolos mediante funciones continuas, lo que se conoce como \textbf{lema de Urysohn}. La formalización de este resultado es uno de los objetivos principales de este trabajo.


\begin{definition}
  Sea $X$ un espacio topológico. Diremos que $X$ es un espacio \textnormal{normal} si para cada par de cerrados disjuntos $C, D \subseteq X$ existen abiertos disjuntos $U$ y $V$ en $X$ tales  que separan $C$ y $D$, es decir, $C \subseteq U$ y $D \subseteq V$\footnote{En Lean, la definición \code{NormalSpace} es ligeramente distinta, pero utiliza objetos que nosotros no hemos usado. En su lugar, utilizamos esta y una demostración de que son equivalentes, a la que he llamado \code{normal\_space\_def}.}.
\end{definition}

\begin{lstlisting}
  def NormalSpace {X : Type} (T : TopologicalSpace X) : Prop :=
    ∀ C : Set X, ∀ D : Set X,
    IsClosed C → IsClosed D → C ∩ D = ∅ →
    ∃ U : Set X, ∃ V : Set X,
      IsOpen U ∧ IsOpen V ∧ C ⊆ U ∧ D ⊆ V ∧ U ∩ V = ∅
\end{lstlisting}

Ahora queremos dar una caracterización para este tipo de espacios, que nos facilitará el trabajo más adelante.

\begin{proposition}[\textbf{Caracterización de espacios normales}]\label{caracterizacion-normal}
  Sea $X$ un espacio topológico. $X$ es normal si y sólo si para cada abierto $U$ y cada cerrado $C$ de $X$ tales que $C \subseteq U$, existe un abierto $V \subset X$ de forma que $C \subseteq V \subseteq \overline{V} \subseteq U$.
\end{proposition}

\begin{lstlisting}
  lemma characterization_of_normal {X : Type} (T : TopologicalSpace X) :
      NormalTopoSpace T ↔
      ∀ U : Set X, ∀ C : Set X, IsOpen U → IsClosed C → C ⊆ U →
        ∃ V : Set X, IsOpen V ∧ C ⊆ V ∧ (Closure V) ⊆ U := by
\end{lstlisting}

\begin{proof}
  Veamos cada implicación por separado.

  \begin{lstlisting}
    rw [normal_space_def]
    constructor \end{lstlisting}

  ($\implies$) Supongamos que $X$ es un espacio normal (\code{hT}) y sean $U$ un abierto (\code{hU}) y $C$ un cerrado (\code{hC}) tales que $C \subseteq U$ (\code{hCU}).

  \begin{lstlisting}
    · intro hT U C hU hC hCU \end{lstlisting}
  
  Puesto que $X$ es normal, por la definición, para $C$ y $U^c$ cerrados en $X$ obtenemos $V_1$ y $V_2$ abiertos (\code{V1\_open}, \code{V2\_open}) disjuntos (\code{hV}) tales que $C \subseteq V_1$ (\code{hCV}) y $U^c \subseteq V_2$ (\code{hUV}).

  \begin{lstlisting}
      obtain ⟨V1, V2, V1_open, V2_open, hCV, hUV, hV⟩ :=
        hT C Uᶜ
        hC
        (by exact isClosed_compl_iff.mpr hU)
        (by rw [ABdisjoint_iff_AsubsBc, compl_compl]; exact hCU) \end{lstlisting}

  Por supuesto, en Lean tenemos que especificar por qué $U^c$ es cerrado y por qué $U^c \subseteq V_2$.
  Tomamos como $V$ el $V_1$ obtenido de esta forma. Ya sabemos que $V_1$ es abierto y que $C\subseteq V_1$, luego sólo falta demostrar que $\overline{V_1} \subseteq U$.

  \begin{lstlisting}
      use V1
      constructor
      · exact V1_open
      constructor
      · exact hCV \end{lstlisting}

  Sabemos que $U^c \subseteq V_2$ (\code{hUV}), luego $V_2^c \subseteq U$. Basta ver que $\overline{V_1} \subseteq V_2^c$.

  Pero $V_1 \cap V_2 = \emptyset \implies \overline{V_1} \cap V_2 = \emptyset$, por ser $V_2$ abierto. Luego $\overline{V_1} \subseteq V_2^c$.

  \begin{lstlisting}
      · trans V2ᶜ; swap
        · exact Set.compl_subset_comm.mp hUV -- V2ᶜ ⊆ U
        · apply Disjoint.closure_left at hV
          specialize hV V2_open -- hV : Disjoint (closure V1) V2
          exact Set.subset_compl_iff_disjoint_right.mpr hV
            -- closure V1 ⊆ V2ᶜ \end{lstlisting}

  ($\impliedby$) Procedemos de manera similar. Sean $C_1$ y $C_2$ cerrados (\code{C1\_closed}, \code{C2\_closed}) disjuntos (\code{hC}). Podemos aplicar la hipótesis (\code{h}) al abierto $C_1^c$ y al cerrado $C_2$ para obtener obtener un abierto $V$ (\code{V\_open}) de manera que $C_2 \subseteq V \subseteq \overline{V} \subseteq C_1^c$ (\code{hV}).

\begin{lstlisting}
    · intro h C1 C2 C1_closed C2_closed hC
      obtain ⟨V, V_open, hV⟩ :=
        h C1ᶜ C2
        (by exact IsClosed.isOpen_compl) C2_closed
        (by rw [← ABdisjoint_iff_AsubsBc, Set.inter_comm C2 C1];
          exact hC)
\end{lstlisting}

  Ahora tomamos los abiertos $U_1 = \overline{V}^c$ y $U_2 = V$. Queremos ver que cumplen la condición de normalidad para $C_1$ y $C_2$, es decir:
  
\begin{lstlisting}
  IsOpen (Closure V)ᶜ ∧ IsOpen V ∧ C1 ⊆ (Closure V)ᶜ ∧ C2 ⊆ V ∧ (Closure V)ᶜ ∩ V = ∅
\end{lstlisting}
  
  En efecto, ambos son abiertos ($\overline{V}^c$ por ser el complementario de una clausura y $V$ por construcción).

\begin{lstlisting}
    constructor
    · apply isOpen_compl_iff.mpr
      exact closure_is_closed V
    constructor
    · exact V_open
\end{lstlisting}

  Además, $C_1 \subseteq \overline{V}^c$ es equivalente a $\overline{V} \subseteq C_1^c$, que es cierto por construcción de $V$, igual que $C_2 \subseteq V$.
  
\begin{lstlisting}
    constructor
    · apply Set.subset_compl_comm.mp
      exact hV.right
    constructor
    · exact hV.left
\end{lstlisting}

  Por último, se tiene

  $$
  \overline{V}^c \cap V = \emptyset \iff V \cap \overline{V}^c = \emptyset \iff
  V \subseteq \overline{V}^{cc} \iff V \subseteq \overline{V},
  $$

  que es cierto por las propiedades de la adherencia.

\begin{lstlisting}
    · rw [Set.inter_comm]
      rw [ABdisjoint_iff_AsubsBc]
      simp
      exact set_inside_closure V
\end{lstlisting}


\end{proof}