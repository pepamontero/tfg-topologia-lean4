

\section{El Lema de Urysohn}

[Introducción] \redcode{no se que poner}

\begin{theorem}[\textbf{Lema de Urysohn}]
  Sea $(X, \mathcal{T})$ un espacio topológico. $X$ es un espacio normal si y solo si para cada par de conjuntos cerrados disjuntos $C$ y $D$ en $X$, existe una función $f : X \to [0, 1]$ de manera que $f(C) = \{0\}$ y $f(D) = \{1\}$.
\end{theorem}

Para la fomalización en Lean, pediremos que los cerrados $C$ y $D$ sean no vacíos. Obviamente, si uno de los dos es vacío, basta tomar la función continua $f(x) \equiv 1$, pero podemos descartar estos casos triviales.

\begin{lstlisting}
  lemma Urysohn {X : Type} {Y : Set ℝ} (T : TopologicalSpace X)
      [T' : TopologicalSpace ℝ] (hT' : T' = UsualTopology)
      {R : TopologicalSpace Y} {hY : Y = Set.Icc 0 1}
      {hR : R = TopoSubspace T' Y} :
      NormalSpace X ↔
        ∀ C1 : Set X, ∀ C2 : Set X, C1 ≠ ∅ → C2 ≠ ∅ →
        IsClosed C1 → IsClosed C2 → Disjoint C1 C2 →
        ∃ f : X → Y, Continuous f ∧
          f '' C1 = ({⟨0, by simp [hY]⟩} : Set Y) ∧
          f '' C2 = ({⟨1, by simp [hY]⟩} : Set Y) := by sorry
\end{lstlisting}

Veamos primero la demostración del recíproco, que es más sencilla.

\begin{proof}

  Supongamos que cualquier par de cerrados disjuntos de $X$ se pueden separar mediante una función continua y veamos que entonces $X$ es un espacio normal. Sean $C_1$ y $C_2$ cerrados disjuntos en $X$.

  \begin{lstlisting}
    · intro h
      rw [normal_space_def]
      intro C1 C2 hC1 hC2 hinter \end{lstlisting}

  Como en la definición de normal no pedimos que los cerrados sean no vacíos, tenemos que diferenciar estos casos. Sin embargo, estos casos son triviales porque basta tomar el conjunto vacío para recubrir el vacío y $X$ para recubrir el otro conjunto. En Lean hay que ser rigurosos con este paso, pero aquí lo obviaremos por simplicidad.

  Supongamos entonces que $C_1$ y $C_2$ son no vacíos. Por hipótesis, existe una función continua $f : X \to [0, 1]$ de forma que $f(C_1) = \{0\}$ y $f(C_2) = \{1\}$.

  \begin{lstlisting}
    obtain ⟨f, hf, hfC1, hfC2⟩ := h C1 C2 hC1nempty hC2nempty hC1 hC2 hinter \end{lstlisting}

  Consideremos entonces los conjuntos $U_1 = f^{-1}([0, \frac{1}{2}))$ y $U_2 = f^{-1}((\frac{1}{2}, 1])$. Queremos ver que son los abiertos que necesitamos de la definición de normal, es decir, que son abiertos en $X$, que $C_i \subseteq U_i$ y que son disjuntos.

  \begin{lstlisting}
    use f ⁻¹' ({y | (y : ℝ) ∈ Set.Ico 0 (1 / 2)})
    use f ⁻¹' ({y | (y : ℝ) ∈ Set.Ioc (1 / 2) 1}) \end{lstlisting}

  Para ver que $U_1$ es abierto, utilizamos que $f$ es continua. Basta ver que $[0, \frac{1}{2})$ es abierto en $[0, 1]$. Pero ya vimos que los intervalos de la forma $[0, b)$ son abiertos en $[0, 1]$, así que basta aplicar esta propiedad. Análogo para $U_2$.

  \begin{lstlisting}
    · apply hf -- aplicar def. de f continua
      apply ico_open_in_Icc01 -- `[0, b)` es abierto en `[0, 1]`
      · exact hY -- estamos en [0, 1]
      · exact hR -- estamos en la top. relativa
      · norm_num -- 0 < 1/2 < 1 \end{lstlisting}

  Para ver que $C_1 \subseteq U_1$, basta ver que $f(C_1) \subseteq [0, \frac{1}{2})$. Que es trivial. Análogo para $U_2$.

  \begin{lstlisting}
    · rw [← Set.image_subset_iff, hfC1] -- `{0} ⊆ [0, 1/2)` ?
      simp \end{lstlisting}

  Para ver que son disjuntos, vemos que $[0, \frac{1}{2})$ y $(\frac{1}{2}, 1]$ son disjuntos. Obviamente lo son, pero para Lean es un poco más complicado, así que procedemos por reducción al absurdo para poder simplificar las expresiones. Finalmente llegamos a que no existe un $x$ con $x < 1/2$ y $x > 1/2$.

  \begin{lstlisting}
    · apply Disjoint.preimage
      by_contra c
      rw [Set.disjoint_iff_inter_eq_empty, ← ne_eq, ← Set.nonempty_iff_ne_empty] at c
      obtain ⟨x, hxu, hxv⟩ := c
      simp at hxu hxv
      linarith \end{lstlisting}
\end{proof}


La otra implicación es mucho más compleja, especialmente en su formalización en Lean, como veremos a continuación.


\subsection{Esquema de la demostración}

Para demostrar esta implicación, dados dos cerrados disjuntos no vacíos de $X$, queremos construir una función continua que los separe. La construcción de esta función ha constituido la parte más costosa de este trabajo.

Vamos a ver un esquema de los pasos a seguir para construir tal función.

Supongamos que $X$ es un espacio normal, y sean $C_1$ y $C_2$ dos cerrados disjuntos no vacíos de $X$.

Consideremos $U_1 = X$ abierto. Consideremos el cerrado $C_1$ el abierto $C_2^c$ y aplicamos la caracterización de espacios normales (\ref{caracterizacion-normal}), obteniendo otro abierto $U_0$ de manera que
$$
C_1 \subseteq U_0 \subseteq \overline{U_0} \subseteq C_2^c \subseteq U_1 = X
$$
Podemos hacer lo mismo para $\overline{U_0}$ cerrado y $C_2^c$ abierto, obteniendo $U_{\frac{1}{2}}$ de forma que
$$
C_1 \subseteq U_0 \subseteq \overline{U_0} \subseteq U_{\frac{1}{2}} \subseteq \overline{U_{\frac{1}{2}}} \subseteq C_2^c \subseteq U_1
$$
En general, vamos a construir una sucesión de abiertos sobre $\mathbb{Q}\cap[0, 1]$, $\{U_p | p \in \mathbb{Q}\cap[0, 1]\}$, de manera que
\begin{equation}
  \forall p , q \in \mathbb{Q}, p < q \implies \overline{U_p} \subseteq U_q \tag{$\star$} \label{eq:star}
\end{equation}

Una vez tenemos esta sucesión, que en Lean será una función $G : \mathbb{Q}\cap[0, 1] \to \mathcal{P}(X)$, definimos otra función $F$ sobre $X$ que a cada $x \in X$ le hace corresponder el conjunto
$$
F(x) = \{p \in \mathbb{Q} ~|~ x \in G(p)\}
$$
Por último, tomaremos la función $f : X \to [0, 1]$ definida por
$$
f(x) = \textnormal{inf}~F(x)
$$
Esta función será la que utilicemos. Tendremos que demostrar que efectivamente toma valores en $[0, 1]$, que es continua y que separa nuestros conjuntos cerrados.

Sin embargo, una vez construidas estas funciones, este último paso es relativamente sencillo. La principal dificultad a la hora de formalizar esta demostración ha sido el uso de la inducción para construir la función $G$ y demostrar sus propiedades.

Como se puede apreciar en las primeras iteraciones de la construcción de cada $U_q$, esta sucesión se construye por inducción. Para poder hacer inducción sobre los racionales, nos basamos en que son numerables, y, en particular, en que $\mathbb{Q}\cap[0, 1]$ lo es. Vamos a encontrar una función $f : \mathbb{N} \to \mathbb{Q} \cap [0, 1]$ biyectiva (invertible), de manera que $f(0) = 1$ y $f(1) = 0$. Esto nos servirá para construir cada $U_q$.

Después, para demostrar que efectivamente se cumple la condición (\ref{eq:star}), necesitaremos utilizar inducción sobre dos variables. Para ello, vamos a demostrar que el orden lexicográfico de $(\mathbb{N} \times \mathbb{N})$, definido por $(n, m) < (n', m') \iff n<n' \lor (n=n' \land m<m')$, es una relación bien fundada, y por tanto admite inducción sobre pares de naturales.

\begin{lstlisting}
  Nota: no se como poner que lo más difícil ha sido que no se me han ocurrido estas cosas a la primera jajajaja
\end{lstlisting}

\subsection{Construcción de la sucesión de abiertos}

Sea $Q = \mathbb{Q}\cap[0, 1]$ Para construir la sucesión $\{U_p ~|~ p \in Q\}$, o, lo que es lo mismo, la función $G : Q \to \mathcal{P}(X)$, $G(p) = U_p$, vamos a proceder de la siguiente forma.

Como $Q$ es numerable, consideramos la numeración $Q = \{p_k ~|~ k \in \mathbb{N}\}$, y supongamos por simplicidad que $p_0 = 1$ y que $p_1 = 0$. Vamos a construir los abiertos con la condición (\ref{eq:star}) por inducción sobre $k$.

Tomamos entonces, como base de la inducción,

\begin{itemize}
  \item $U_1 = U_{p_0} = X$.
  \item $U_0 = U_{p_1}$ el abierto obtenido al aplicar la caracterización de espacios normales (\ref{caracterizacion-normal}) al cerrado $C_1$ y el abierto $C_2^c$.
\end{itemize}

Trivialmente se tiene que $\overline{U_0} \subseteq U_1 = X$ (con $0<1$), luego se satisface (\ref{eq:star}).

Ahora, para el caso inductivo, supongamos que hemos definido $U_{p_k}$ para cada $k = 0, 1, ..., n$ satisfaciendo (\ref{eq:star}), y ahora queremos construir $U_{p_{n+1}}$.

Notar que el conjunto $\{p_0, p_1, ..., p_n\} \subset Q$ no está necesariamente ordenado. Sin embargo, es un conjunto finito de números racionales, por tanto, podemos encontrar unos elementos $p_r$ y $p_s$ de manera que $p_r$ es el predecesor inmediato de $p_{n+1}$ y $p_s$ es el sucesor inmediato de $p_{n+1}$. Es decir, se tiene
$$
p_r < p_{n+1} < p_s
$$
y no existe $k\leq n$ de forma que $p_r < p_k < p_{n+1}$ ni $p_{n+1} < p_k < p_s$.

Puesto que $p_r < p_s$, por la hipótesis de inducción se tiene que ambos son abiertos y que $\overline{U_{p_r}} \subseteq U_{p_s}$ (\ref{eq:star}). Aplicamos la caracterización de normalidad para encontrar un nuevo abierto $U = U_{p_{n+1}}$ tal que
$$
\overline{U_{p_r}} \subseteq U \subseteq \overline{U} \subseteq U_{p_s}
$$
Con esto concluimos la inducción.

Veamos ahora como se traduce esto en Lean.

\subsubsection{Numerar los racionales}

Los racionales son numerables, es decir existe una biyección entre $\nat$ y $\rat$. En particular, necesitamos una función $f : \nat \to Q$ donde $Q = \rat \cap [0, 1]$, de forma que $f$ sea biyectiva, $f(0) = 1$ y $f(1) = 0$. Es decir, la función que nos lleva cada $k \in \nat$ a $p_k$.

\begin{lstlisting}
  lemma hf : ∃ f : ℕ → Q,
      (f.Bijective ∧
      f 0 = ⟨1, Q1⟩ ∧
      f 1 = ⟨0, Q0⟩) := by sorry
\end{lstlisting}

Para demostrar la existencia de tal función necesitamos una serie de resultados previos.

En primer lugar, la numerabilidad de los racionales ya está demostrada en Mathlib con el resultado \code{Rat.instDenumerable}. Para extraer una función biyectiva de este resultado, he escrito el siguiente lema:

\begin{lstlisting}
  lemma bijective_nat_rat : ∃ f : ℕ → ℚ, f.Bijective  := by
    have f := (Rat.instDenumerable.eqv).symm
    use f
    exact f.bijective
\end{lstlisting}

Evidentemente, por la independencia de las demostraciones de Lean, no podremos evaluar esta función de manera explícita. Pero tenemos la información que necesitamos de ella.

Ahora, quiero demostrar que existe una función biyectiva de $\nat$ en $Q$. Como ya tenemos una función biyectiva de $\nat$ en $\rat$, la idea es componerla con una biyección de $\rat$ en $Q$.

Para demostrar que esta biyección existe, basta demostrar que $\rat$ y $Q$ tienen el mismo cardinal (\code{Cardinal.eq}). Pero, de hecho, cualquier subconjunto de $\rat$ no finito tiene cardinal $\aleph_0$ (demostrado en \code{non\_finite\_rat\_set\_cardinal\_aleph0}). Basta demostrar que $Q$ no es finito.

\begin{lstlisting}
  lemma non_finite_rat_set_cardinal_aleph0 (A : Set ℚ) (hA : ¬ A.Finite) :
      Cardinal.mk ↑A = Cardinal.aleph0 := by sorry
\end{lstlisting}

Por último, cualquier permutación de dos valores de una función preserva la biyectividad (demostrado en \code{permute\_f\_bijectivity}). Por tanto, podemos forzar que $f(0) = 1$ y $f(1) = 0$.

\begin{lstlisting}
  def permute_f {X Y : Type} [DecidableEq X]
    (f : X → Y) (a b : X) : X → Y := fun x ↦
      if x = a then f b
      else if x = b then f a
      else f x

  lemma permute_f_bijectivity {X Y : Type} [DecidableEq X]
      {f : X → Y} (a b : X) (h : f.Bijective) :
      (permute_f f a b).Bijective := by sorry
\end{lstlisting}

\begin{lstlisting}
  Nota: Todas estas demostraciones y la de hf son bastante largas y técnicas y no me parece que aporten mucho. Quizás se podrían dejar simplemente en el anexo.
\end{lstlisting}

Una vez demostrado \code{hf}, podemos definir $f$ mediante \code{Classical.choose} y empezar a trabajar con ella, aunque no la conozcamos explícitamente.

\begin{lstlisting}
  noncomputable def f : ℕ → Q := Classical.choose hf
\end{lstlisting}

Por ejemplo, podemos probar que tiene inversa.

\begin{lstlisting}
  lemma f_has_inverse :  ∃ g, Function.LeftInverse g f ∧
      Function.RightInverse g f := by
    rw [← Function.bijective_iff_has_inverse]
    exact f_prop.left
\end{lstlisting}

\subsubsection{Encontrar el sucesor y predecesor inmediato}

Ahora tenemos cada $p_k$ definido en Lean como $f(k)$ para cada $k \in \nat$. Para poder definir cada abierto $U_{p_k}$, necesitamos ser capaces de encontrar para cada conjunto $\{p_0, p_1, \dots, p_{n-1}\}$, el predecesor inmediato $p_r$ y el sucesor inmediato $p_s$ de $p_{n}$.

De nuevo, en Lean esto se codifica como funciones; queremos encontrar una función $r : \nat \to \nat$ que, para cada $n>1$, devuelva el predecesor inmediato de $f(n)$, de entre $\{f(k) ~|~ k < n\}$, y lo mismo para una función $s : \nat \to \nat$ que encuentre el sucesor inmediato. Sin embargo, la existencia de tales funciones no es trivial.

\begin{lemma}
  Sea $n > 1$. Entonces existe un $r_n < n$ de forma que $f(r_n) < f(n)$, y si $k < n$ es tal que $f(k) < f(n)$ entonces $f(k) \leq f(r_n)$.
\end{lemma}

\begin{lstlisting}
  lemma exists_r (n : ℕ) (hn : n > 1) : ∃ r ∈ Finset.range n,
    ((f r < f n) ∧
    (∀ m ∈ Finset.range n, f m < f n → f m ≤ f r)) := by sorry
\end{lstlisting}

\begin{proof}
  Sea $n>1$. Consideremos el conjunto
  $$
  R = \{m : \nat ~|~ m < n \land f(m) < f(n)\}
  $$
  \begin{lstlisting}
    let R : Finset ℕ := (Finset.range n).filter (fun m ↦ f m < f n) \end{lstlisting}
  $R$ es un conjunto finito no vacío, pues $1 \in R$
  \begin{lstlisting}
    have hR : R.Nonempty
    · use 1; sorry \end{lstlisting}

  Tomamos el conjunto $f(R)$, que también es un conjunto finito y no vacío, por serlo $R$, luego tiene máximo. Tomamos el argumento máximo de $f(R)$, $r_n = \arg \max \{f(m) ~|~ m \in R\}$, y veamos que satisface las condiciones que pedimos.

  \begin{lstlisting}
    let fR : Finset Q := R.image f
    have hfR : fR.Nonempty := (Finset.image_nonempty).mpr hR
    let fr := Finset.max' fR ((Finset.image_nonempty).mpr hR)
    obtain ⟨r, hr⟩ := Finset.mem_image.mp (by exact Finset.max'_mem fR hfR)
    use r
  \end{lstlisting}

  Se tiene que $r \in R$, luego $r < n$ y $f(r) < f(n)$. Sea entonces un $k < n$ con $f(k) < f(n)$. Por construcción, $k \in R$ y por tanto $f(k) \in f(R)$. Como $r$ es el argumento máximo de $f(R)$, $f(r)$ es el máximo de $f(R)$ y por tanto $f(k) \leq f(R)$, como queríamos.
\end{proof}

La demostración completa está en el anexo, así como el análogo para $s$.

Garantizada la existencia de estas funciones, podemos tomar ahora las funciones $r$ y $s$ y empezar a trabajar con ellas.

\begin{lstlisting}
  noncomputable def r : ℕ → ℕ := fun n ↦
  if h : n > 1 then Classical.choose (exists_r n h)
  else 1

  noncomputable def s : ℕ → ℕ := fun n ↦
  if h : n > 1 then Classical.choose (exists_s n h)
  else 0
\end{lstlisting}